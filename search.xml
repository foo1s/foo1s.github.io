<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2025/05/08/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/05/08/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MySQL8.4安装教程<br><a href="https://blog.csdn.net/m0_65663088/article/details/140001290">Windows安装Mysql8.4,看这一篇就够了（超级详细！）_mysql8.4安装教程-CSDN博客</a></p></blockquote><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 开启操作：`net start MySQL84`</span><br><span class="line">- 关闭操作：`net stop MySQL84`（或者在计算机管理服务中进行开启关闭）</span><br><span class="line">- 显式连接：`mysql -uzhw -pzhw0401 -h&lt;&gt; -p&lt;&gt; &lt;database&gt;`</span><br><span class="line">- 隐式连接：`mysql -uzhw -p -h127.0.0.1`</span><br><span class="line">- 查看版本信息：`select version();`</span><br><span class="line">- 退出连接：`exit`</span><br><span class="line"></span><br><span class="line">- 创建新的用户：CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br><span class="line">- 查看用户密码：SELECT User, authentication_string FROM mysql.user WHERE User=&#x27;你的用户名&#x27;;</span><br><span class="line">- 重置密码：ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;新密码&#x27;;</span><br><span class="line">- FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>一条完整的数据的存储的过程：<br>  创建库–&gt;定字段–&gt;创建表–&gt;插数据</li></ul><h4 id="SQL语句命名的规定与规范"><a href="#SQL语句命名的规定与规范" class="headerlink" title="SQL语句命名的规定与规范"></a>SQL语句命名的规定与规范</h4><h5 id="标识符命名规定"><a href="#标识符命名规定" class="headerlink" title="标识符命名规定"></a>标识符命名规定</h5><ul><li>数据库名、表名不得超过30个字符，变量名限制为29个</li><li>必须只能包含 A–Z, a–z, 0–9, 共63个字符，而且不能数字开头</li><li>数据库名、表名、字段名等对象名中间不能包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名<a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">https://dev.mysql.com/doc/refman/8.0/en/keywords.html</a></li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96; （着重号）引起来</li></ul><h5 id="标识符命名规范"><a href="#标识符命名规范" class="headerlink" title="标识符命名规范"></a>标识符命名规范</h5><ul><li>注释应该清晰、简洁地解释 SQL 语句的意图、功能和影响。</li><li>库、表、列名应该使用小写字母，并使用下划线（)或驼峰命名法。</li><li>库、表、字段名应该简洁明了，具有描述性，反映其所存储数据的含义。</li><li>库名应于对应的程序名一致 例如：程序名为 EcommercePlatform 数据库名命名为ecommerce_platform”</li><li>表命名最好是遵循 “业务名称_表”的作用  例如：alipay_task 、 force_project、 trade_config </li><li>列名应遵循“表实体_属性”的作用 例如：product_name 或 productName</li></ul><h4 id="MySQL所有条件操作符"><a href="#MySQL所有条件操作符" class="headerlink" title="MySQL所有条件操作符"></a>MySQL所有条件操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=</span><br><span class="line">!=</span><br><span class="line">&lt;</span><br><span class="line">&lt;=</span><br><span class="line">&gt;</span><br><span class="line">&gt;=</span><br><span class="line">between</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2025/05/08/DDL%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/05/08/DDL%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>DDL语言主要用于定义和管理数据库的结构，包括库，表，索引，视图等数据库对象的创建与修改<br>不涉及对数据的操作，而是更关注于数据库的结构与元数据</p><h3 id="DDL常用操作"><a href="#DDL常用操作" class="headerlink" title="DDL常用操作"></a>DDL常用操作</h3><h4 id="DDL常用语言"><a href="#DDL常用语言" class="headerlink" title="DDL常用语言"></a>DDL常用语言</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create </span><br><span class="line"></span><br><span class="line">alter</span><br><span class="line"></span><br><span class="line">drop</span><br><span class="line"></span><br><span class="line">show databases/columns/tables from column/status/ create database/ grants/..</span><br></pre></td></tr></table></figure><h4 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select column1,column2 from table;</span><br><span class="line"></span><br><span class="line">select * from table // 所有列</span><br><span class="line"></span><br><span class="line">select distinct column from table //去重，应用于所有列</span><br><span class="line"></span><br><span class="line">select column from table limit 5,4 //从行5开始的4行</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select pro_name from prroducts order by pro_name 选择一个列进行排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select prod_id,prod_price,prod_xx from products order by prod_id,prod_price;</span><br><span class="line">按照多个列进行排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select prod_id,prod_price,prod_xx from products order by prod_id desc; 降序</span><br><span class="line">哪个列降序就把desc放在哪个列的后面</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select pro_name from products where pro_price=2.5 过滤price=2.5的数值</span><br><span class="line">--&gt;注意将order by语句放在where之后</span><br><span class="line"></span><br><span class="line">select pro_name from products where pro_price between 5 and 10 ; &gt;and</span><br><span class="line"></span><br><span class="line">select cust-ID FROM coutomers WHERE cust-EMAIL IS NULL; &gt;NULL</span><br><span class="line"></span><br><span class="line">----组合where语句---</span><br><span class="line">select xx,xx,xx from xx where xx=a and xx=b  &gt;and</span><br><span class="line"></span><br><span class="line">select xx,xx,xx from xx where xx=a and xx=b  &gt;or</span><br><span class="line">and的优先级高于or,最好使用()进行合理区分</span><br><span class="line"></span><br><span class="line">select columns1, column2 from table where id in (100,200) order by xx  &gt;in</span><br><span class="line"></span><br><span class="line">select columns1, column2 from table where id  not in (100,200) order by xx  &gt;not</span><br></pre></td></tr></table></figure><h4 id="使用通配符进行过滤"><a href="#使用通配符进行过滤" class="headerlink" title="使用通配符进行过滤"></a>使用通配符进行过滤</h4><ul><li><p>为了在搜索语句中使用通配符，必须使用LIKE操作符</p></li><li><p>操作符何时不是操作符，当它作为谓词的时候</p></li><li><p>百分号<code>%</code>通配符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_id,pro_name from products wher prod_name like &#x27;jet%&#x27;;</span><br></pre></td></tr></table></figure><ul><li>注意尾空格，<code>%</code>不会匹配尾空格</li><li><code>%</code>不能匹配NULL</li></ul></li><li><p>下划线<code>_</code>通配符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select xx from xx where pro_name like &#x27;_ &#x27;</span><br></pre></td></tr></table></figure><ul><li><code>只能匹配一个字符</code></li></ul></li></ul><h4 id="使用正则表达式进行搜索"><a href="#使用正则表达式进行搜索" class="headerlink" title="使用正则表达式进行搜索"></a>使用正则表达式进行搜索</h4><ul><li>默认不区分大小写</li></ul><h5 id="基本字符匹配"><a href="#基本字符匹配" class="headerlink" title="基本字符匹配"></a>基本字符匹配</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">select pro_name</span><br><span class="line">from products</span><br><span class="line">where pro_name REGEXP &#x27;.100&#x27;</span><br><span class="line">order by pro_name</span><br><span class="line"></span><br><span class="line">1. 进行or匹配</span><br><span class="line">REGEXP &#x27;100|200&#x27;</span><br><span class="line"></span><br><span class="line">2.匹配几个or字符</span><br><span class="line">REGEXP &#x27;[^123] ton&#x27;</span><br><span class="line">REGEXP &#x27;[1-3] ton&#x27;</span><br><span class="line"></span><br><span class="line">3.匹配特殊字符</span><br><span class="line">&#x27;\\ .&#x27;</span><br><span class="line">使用\\作为转义字符</span><br><span class="line"></span><br><span class="line">4.匹配字符类</span><br><span class="line"></span><br><span class="line">5.匹配多个实例</span><br><span class="line"></span><br><span class="line">6.定位符</span><br><span class="line">^ (插入符号)：</span><br><span class="line">将匹配限制在字符串的开头。</span><br><span class="line">例如，^abc 只匹配以 &quot;abc&quot; 开头的字符串。</span><br><span class="line"></span><br><span class="line">$ (美元符号)：</span><br><span class="line">将匹配限制在字符串的结尾。</span><br><span class="line">例如，xyz$ 只匹配以 &quot;xyz&quot; 结尾的字符串</span><br></pre></td></tr></table></figure><ul><li><code>.</code> 可以匹配任意字符</li><li><code>LIKE</code>匹配整个列，如果被匹配文本在列值中出现，则LIKE将不会找到他</li></ul><h4 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h4><h5 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h5><ul><li>计算字段是在运行时，在select()语句内部进行创建的</li></ul><h5 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.MySQL:将两个列拼接起来：</span><br><span class="line">-Concat()</span><br><span class="line"></span><br><span class="line">2.一般的DBMS系统</span><br><span class="line">-使用+或者||</span><br><span class="line"></span><br><span class="line">select Concat(Rtrim(xx)),&#x27;(&#x27;,Rtrim(xx)),&#x27;)&#x27; as xxx</span><br></pre></td></tr></table></figure><h5 id="执行算数计算"><a href="#执行算数计算" class="headerlink" title="执行算数计算"></a>执行算数计算</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id,num,price,num*price as all_price</span><br><span class="line">from orintity </span><br><span class="line">whhere origin_num = 2005;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2025/05/08/%E5%87%BD%E6%95%B0%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/05/08/%E5%87%BD%E6%95%B0%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select name,Upper(name) AS name_case </span><br><span class="line">FROM xxx</span><br><span class="line">order by xxx;</span><br><span class="line"></span><br><span class="line">left():返回左边的字符</span><br><span class="line">length():返回长度</span><br><span class="line">Locate():找出一个字串</span><br><span class="line">Lower():将串转化为小写</span><br><span class="line">LTrim():去除串左边的空格</span><br><span class="line">Soundex():返回串的SOUNDEX值</span><br><span class="line">where Soundex(cust_contact) = Soundex(&#x27;Y Lie&#x27;);</span><br><span class="line">Substring():返回子串的字符</span><br></pre></td></tr></table></figure><h4 id="时间和日期处理函数"><a href="#时间和日期处理函数" class="headerlink" title="时间和日期处理函数"></a>时间和日期处理函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">日期表示格式：yyyy-mm-dd</span><br><span class="line"></span><br><span class="line">1.查找特定的日期：</span><br><span class="line">where Data(Order_data) = &#x27;2005-09-01&#x27;</span><br><span class="line"></span><br><span class="line">2.查找特定月份</span><br><span class="line">- where Year(order_data) = 2005 AND Month(order_data) = 9;</span><br><span class="line">- where Data(order_data) Between &#x27;2005-09-01&#x27; and &#x27;2005-09-30</span><br></pre></td></tr></table></figure><h3 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h3><h4 id="常用聚集函数"><a href="#常用聚集函数" class="headerlink" title="常用聚集函数"></a>常用聚集函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVG()  返回某列平均值</span><br><span class="line">COUNT() 返回某列行数</span><br><span class="line">MAX() </span><br><span class="line">MIN()</span><br><span class="line">SUM()</span><br><span class="line">DISTINCT() 不选取指定列中的重复值，只选取一次重复值</span><br></pre></td></tr></table></figure><ul><li><p>AVG()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select AVG(xxx) as avg_price</span><br><span class="line">from products</span><br><span class="line">where id =1001</span><br></pre></td></tr></table></figure></li><li><p>COUNT()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.COUNT(*)</span><br><span class="line">对表中所有行进行计数，无论其是否含有空值</span><br><span class="line"></span><br><span class="line">2.COUNT(column)</span><br><span class="line">对特定列中具有值得行进行计数</span><br></pre></td></tr></table></figure></li><li><p>DISTINCT()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select AVG(DISTINCT grod_privce) AS avg_price</span><br></pre></td></tr></table></figure></li></ul><h3 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h3><h4 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Group By</span><br><span class="line"></span><br><span class="line">select id,count(*) As num</span><br><span class="line">from products</span><br><span class="line">Group By id</span><br><span class="line">-&gt;按照每个独立的id进分组排序，并计算相应的num数值</span><br><span class="line">-&gt;使用with rollup 可以得到每个分组以分组汇总级别的数值</span><br></pre></td></tr></table></figure><ul><li>group by语句必须在where语句之后，在order by语句之前</li><li>一般在使用groupby语句时，也应该给出order by语句，保证排序的准确性</li></ul><h4 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAVING</span><br><span class="line"></span><br><span class="line">select id, COUNT(*) as num</span><br><span class="line">form product</span><br><span class="line">where price&gt;=10</span><br><span class="line">Group by id</span><br><span class="line">HAVING COUNT(*) &gt;=2;</span><br></pre></td></tr></table></figure><ul><li>能用where表示的都可以使用HAVING表示</li><li>where在分组前进行过滤，HAVING在分组后进行过滤</li></ul><h4 id="select子句顺序"><a href="#select子句顺序" class="headerlink" title="select子句顺序"></a>select子句顺序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select-&gt;from-&gt;where-&gt;group by-&gt;HAVING-&gt;order by-&gt;LIMIT</span><br></pre></td></tr></table></figure><h3 id="使用子查询-subquery"><a href="#使用子查询-subquery" class="headerlink" title="使用子查询(subquery)"></a>使用子查询(subquery)</h3><h4 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id</span><br><span class="line">FROM orders</span><br><span class="line">where order_num in(select order_num</span><br><span class="line">from orderintems</span><br><span class="line">where prod_id = &#x27;TNT2&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select cust_name,</span><br><span class="line">cust_state,</span><br><span class="line">(select COUNT(*)</span><br><span class="line"> from orders</span><br><span class="line"> where order.cust_id = custmer.cust_id) as orders</span><br><span class="line">from custmers</span><br><span class="line">order by cust_name;</span><br></pre></td></tr></table></figure><h3 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h3><h4 id="使用别表名"><a href="#使用别表名" class="headerlink" title="使用别表名"></a>使用别表名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select name,contact</span><br><span class="line">from customers as c, order as o</span><br></pre></td></tr></table></figure><h4 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select p1.name, p1.id</span><br><span class="line">from products as p1, products as p2</span><br><span class="line">where p1.vend_id = p2.vend_id</span><br><span class="line">and p2.prod_id = &#x27;rrr&#x27;</span><br></pre></td></tr></table></figure><h4 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h4><ul><li>自然联结排除多次出现，使得每个列只返回一次</li></ul><h4 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h4><ul><li>联结在那些相关表中没有关联的行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left outer join 选择左边表格全部列</span><br><span class="line">right outer join 选择右边表格的全部列</span><br><span class="line"></span><br><span class="line">select customer.id, order.num</span><br><span class="line">from custmers Left outer join orders</span><br><span class="line">on customers.id = orders.id</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用带聚合函数的联结"><a href="#使用带聚合函数的联结" class="headerlink" title="使用带聚合函数的联结"></a>使用带聚合函数的联结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select customer.id, customer.name,</span><br><span class="line">count(order.num) as num_ord</span><br><span class="line">from custmers inner join orders</span><br><span class="line">on customers.id = orders.id</span><br><span class="line">group by custmers.id</span><br></pre></td></tr></table></figure><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><ul><li>多个查询语句，并作为单个查询结果作为返回</li></ul><h4 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Union</span><br><span class="line"></span><br><span class="line">select xx </span><br><span class="line">from xx</span><br><span class="line">where xx</span><br><span class="line">UNION</span><br><span class="line">select xx</span><br><span class="line">from xx</span><br><span class="line">where xx</span><br></pre></td></tr></table></figure><h4 id="UNION使用规则"><a href="#UNION使用规则" class="headerlink" title="UNION使用规则"></a>UNION使用规则</h4><ul><li>union必须由两个或者两个以上的select语句组成</li><li>union中的每个查询必须包含相同的列，表达式或者聚合函数</li><li>使用union会自动去除重复的行，可使用union all解决</li><li>使用order by进行排序的过程中，须放在组后一个select语句之后</li></ul><h3 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h3><h4 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.启用全文本搜索支持</span><br><span class="line">create tabel xxx&#123;</span><br><span class="line">FULLTEXT(note_text) //指定一个note_text列</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.进行全文本搜索</span><br><span class="line">-where语句中进行排序</span><br><span class="line">where Match(note_text) Against(&#x27;rabbit&#x27;);</span><br><span class="line">match与fulltext需要匹配</span><br><span class="line">相比较普通排序，会给出它认为的优先排序等级</span><br><span class="line"></span><br><span class="line">-select语句中进行排序</span><br><span class="line">select note_text,</span><br><span class="line">Match(note_text) Against(&#x27;rabbit&#x27;) As ranks</span><br><span class="line"></span><br><span class="line">3.扩展排序</span><br><span class="line">where Match(note_text) Against(&#x27;rabbit&#x27;, with ouery expansion);</span><br><span class="line"></span><br><span class="line">4.布尔文本搜索</span><br><span class="line">- 即使没有fulltext索引也可以使用</span><br><span class="line">- where Match(note_text) Against(&#x27;rabbit&#x27;，in boolean mode);</span><br><span class="line"></span><br><span class="line">5.常用的布尔操作符与注意事项</span><br></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert</span><br></pre></td></tr></table></figure><h4 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.直接插入value值(不安全)</span><br><span class="line">insert into cust</span><br><span class="line">values(null,</span><br><span class="line">xx</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">2.先列出key值再插入(安全)</span><br><span class="line">insert into cust(cust_name,</span><br><span class="line">cust_address,</span><br><span class="line">xx,</span><br><span class="line">xx</span><br><span class="line">)</span><br><span class="line">values(</span><br><span class="line">&#x27;zxz&#x27;,</span><br><span class="line">&#x27;xx&#x27;</span><br><span class="line">);</span><br><span class="line">cust_id的NULL值是不需要的</span><br></pre></td></tr></table></figure><ul><li>第一列的id列一般可以自动补全</li></ul><h4 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">insert into cust(cust_name,</span><br><span class="line">cust_address,</span><br><span class="line">xx,</span><br><span class="line">xx</span><br><span class="line">)</span><br><span class="line">values(</span><br><span class="line">&#x27;zxz&#x27;,</span><br><span class="line">&#x27;xx&#x27;</span><br><span class="line">)</span><br><span class="line">values(</span><br><span class="line">&#x27;zxz&#x27;,</span><br><span class="line">&#x27;xx&#x27;</span><br><span class="line">)；</span><br></pre></td></tr></table></figure><ul><li>提升整体性能：<code>insert low priority into</code></li></ul><h4 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">insert into cust(cust_name,</span><br><span class="line">cust_address,</span><br><span class="line">xx,</span><br><span class="line">xx</span><br><span class="line">)</span><br><span class="line">select cust_id</span><br><span class="line">xxx,</span><br><span class="line">xxx,</span><br><span class="line">from cust2;</span><br></pre></td></tr></table></figure><ul><li>列名不需要匹配</li></ul><h3 id="更新与删除数据"><a href="#更新与删除数据" class="headerlink" title="更新与删除数据"></a>更新与删除数据</h3><ul><li>更新与删除数据的过程均不要忘记使用where语句</li></ul><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>删除指定列的某一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update table</span><br><span class="line">set email = &#x27;&#x27;</span><br><span class="line">name = &#x27;null&#x27; 若设置为null可视为删除</span><br><span class="line">where id = &#x27;&#x27;</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li>删除指定的行</li><li>仅删除表的内容，而不会删除表</li><li>若想要删除整个表格，可以使用<code>truncate table</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from cust</span><br><span class="line">where id = &#x27;&#x27;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2025/05/08/%E8%A1%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/05/08/%E8%A1%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><h4 id="创建表基础"><a href="#创建表基础" class="headerlink" title="创建表基础"></a>创建表基础</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table table1</span><br><span class="line">(</span><br><span class="line">id int not null Auto_increment</span><br><span class="line">name char(50) not null</span><br><span class="line">money int nor null default 1</span><br><span class="line">primary key(id)</span><br><span class="line">)</span><br><span class="line">Engine=InnoDB</span><br></pre></td></tr></table></figure><h4 id="关于null值"><a href="#关于null值" class="headerlink" title="关于null值"></a>关于null值</h4><ul><li>null值就是没有值或者缺值，允许null值的列，允许再插入时不给出值</li><li><code>&#39; &#39;</code>不是null值</li><li>主键只能使用<code>not null</code></li></ul><h4 id="关于AUTO-INCREMENT"><a href="#关于AUTO-INCREMENT" class="headerlink" title="关于AUTO_INCREMENT"></a>关于AUTO_INCREMENT</h4><ul><li>每个表只允许一个AUTO_INCREMENT列</li><li>使用<code>select last_insert_id()</code>来确定最后一个AUTO_INCREMENT值</li></ul><h4 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h4><ul><li>InnoDB<br>可靠的事物处理引擎，不支持全文搜索</li><li>MEMORY<br>数据存储在内存，速度很快，适用于临时表</li><li>MyISAm<br>性能极高的引擎，支持全文本搜索</li><li><strong>外键不能跨引擎</strong></li></ul><h4 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE vendos</span><br><span class="line">ADD vend_phone CHAR(20)</span><br><span class="line"></span><br><span class="line">ALTER TABLE vendos</span><br><span class="line">DROP COLUMN vend_phone</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Drop table table1</span><br></pre></td></tr></table></figure><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename table1 to table2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2025/05/08/MySQL%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/05/08/MySQL%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li>视图是<strong>虚拟的表</strong>，在select层面简化检索数据的查询操作</li><li>每次使用视图时，都必须处理查询执行时所需的任一检索</li></ul><h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><h4 id="视图基本语法"><a href="#视图基本语法" class="headerlink" title="视图基本语法"></a>视图基本语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create view</span><br><span class="line"></span><br><span class="line">show create view viewname</span><br><span class="line"></span><br><span class="line">drop </span><br></pre></td></tr></table></figure><h4 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create view product as</span><br><span class="line">select xx,xx,xx</span><br><span class="line">from table1,table2,table3</span><br><span class="line">where table1.id = table2.num</span><br><span class="line">  table1.num = table3.num</span><br></pre></td></tr></table></figure><h4 id="利用视图重新格式化检索出的数据"><a href="#利用视图重新格式化检索出的数据" class="headerlink" title="利用视图重新格式化检索出的数据"></a>利用视图重新格式化检索出的数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">#### 利用视图过滤不想要的数据</span><br><span class="line">```MySQL</span><br></pre></td></tr></table></figure><h4 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">#### 更新视图</span><br><span class="line">```MySQL</span><br></pre></td></tr></table></figure><ul><li>如果MySQl不能准确的确定被更新数据的基数据，则不允许更新（包括插入与删除）</li><li>一般情况下将试图用于检索而不是更新</li></ul><h3 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><ul><li>存储过程的好处：简单，安全，高性能</li></ul><h4 id="使用存储过程-1"><a href="#使用存储过程-1" class="headerlink" title="使用存储过程"></a>使用存储过程</h4><h5 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h5><ul><li>CALL接受存储过程中的名字以及需要传递给它的任一参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">call product(</span><br><span class="line">@xxx</span><br><span class="line">@xxx</span><br><span class="line">@xxx</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h5 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.简单示例</span><br><span class="line">create PROCEDURE AS priceaverage</span><br><span class="line">BEGIN</span><br><span class="line"> SELECT AVG(privce) AS priceverge</span><br><span class="line"> FROM products</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">2.mysql命令行客户机的分隔符</span><br><span class="line">DELIMITER // </span><br><span class="line">为了解释存储过程内部的;字符</span><br><span class="line">除了\符号为外，任何字符均可以</span><br><span class="line"></span><br><span class="line">3.使用此存储过程</span><br><span class="line">call priceaverage();</span><br></pre></td></tr></table></figure><h5 id="带参数创建"><a href="#带参数创建" class="headerlink" title="带参数创建"></a>带参数创建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE GetUserInfo(</span><br><span class="line">    IN userId INT,</span><br><span class="line">    OUT userName VARCHAR(255),</span><br><span class="line">    OUT userEmail VARCHAR(255)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT name, email</span><br><span class="line">    INTO userName, userEmail</span><br><span class="line">    FROM users</span><br><span class="line">    WHERE id = userId;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">in:传入存储过程 入参</span><br><span class="line">out:传出存储过程</span><br><span class="line">into 保存至特定的变量</span><br><span class="line"></span><br><span class="line">call(250,</span><br><span class="line">@userName,</span><br><span class="line">@userEmail</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">select @userName</span><br></pre></td></tr></table></figure><h5 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE ApplyOrderDiscount(</span><br><span class="line">    IN orderId INT</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE orderAmount DECIMAL(10, 2);  //定义了两个局部变量</span><br><span class="line">    DECLARE discountAmount DECIMAL(10, 2); </span><br><span class="line"></span><br><span class="line">    -- 获取订单金额</span><br><span class="line">    SELECT order_amount INTO orderAmount</span><br><span class="line">    FROM orders</span><br><span class="line">    WHERE order_id = orderId;</span><br><span class="line"></span><br><span class="line">    -- 根据订单金额应用折扣</span><br><span class="line">    IF orderAmount &gt;= 1000 THEN</span><br><span class="line">        SET discountAmount = orderAmount * 0.1; -- 10% 折扣</span><br><span class="line">    ELSEIF orderAmount &gt;= 500 THEN</span><br><span class="line">        SET discountAmount = orderAmount * 0.05; -- 5% 折扣</span><br><span class="line">    ELSE</span><br><span class="line">        SET discountAmount = 0; -- 无折扣</span><br><span class="line">    END IF;</span><br><span class="line"></span><br><span class="line">    -- 更新订单表</span><br><span class="line">    UPDATE orders</span><br><span class="line">    SET order_amount = orderAmount - discountAmount,</span><br><span class="line">        discount_applied = 1</span><br><span class="line">    WHERE order_id = orderId;</span><br><span class="line"></span><br><span class="line">    -- 返回折扣金额 (可选)</span><br><span class="line">    SELECT discountAmount;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><ul><li>游标时存储在MySQL服务器上的数据库查询，他并不是一条select语句，而是被该语句检索出来的结果集</li><li><strong>MYSQL游标只能用于存储过程</strong></li></ul><h4 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h4><h5 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create procedure processorder()</span><br><span class="line">begin </span><br><span class="line">declare ordernaumbers CURSOR</span><br><span class="line">for</span><br><span class="line">select order_num from orders</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h5 id="打开于关闭游标"><a href="#打开于关闭游标" class="headerlink" title="打开于关闭游标"></a>打开于关闭游标</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open ordernumbers;</span><br><span class="line">close ordernumbers</span><br></pre></td></tr></table></figure><h5 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch 语句用来分别访问游标的每一行</span><br><span class="line"></span><br><span class="line">declare local variables</span><br><span class="line">declare o int;</span><br><span class="line">declare ordernaumbers CURSOR</span><br><span class="line">for</span><br><span class="line">select order_num from orders</span><br><span class="line">open ordernaumbers</span><br><span class="line">fetch ordernaumbers into o //从第一行开始到一个名为o的局部变量中</span><br></pre></td></tr></table></figure><h5 id="更为复杂的游标数据"><a href="#更为复杂的游标数据" class="headerlink" title="更为复杂的游标数据"></a>更为复杂的游标数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">declare done boolean default 0;</span><br><span class="line">declare o int;</span><br><span class="line"></span><br><span class="line">declare ordernumbers cursor</span><br><span class="line">for </span><br><span class="line">select order_num from orders;</span><br><span class="line"></span><br><span class="line">declare continue handler for SQLSTATE &#x27;02000&#x27; set done 1;</span><br><span class="line"></span><br><span class="line">open ordernumbers</span><br><span class="line">repeat</span><br><span class="line"> fetch ordernumbers into o;</span><br><span class="line">until done end repeat;</span><br><span class="line"></span><br><span class="line">close ordernumbers;</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h3 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h3><ul><li>触发器时MySQl响应以下语句而自动执行的一条MySQL语句<ul><li>insert</li><li>delete</li><li>update</li></ul></li></ul><h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.触发器名称</span><br><span class="line">2.关联的表</span><br><span class="line">3.响应的活动</span><br><span class="line">4.触发器何时执行</span><br></pre></td></tr></table></figure><h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop trigger newsxx;</span><br></pre></td></tr></table></figure><h4 id="使用触发器-1"><a href="#使用触发器-1" class="headerlink" title="使用触发器"></a>使用触发器</h4><h5 id="insert触发器"><a href="#insert触发器" class="headerlink" title="insert触发器"></a>insert触发器</h5><ul><li>引用<code>new</code>虚拟表，访问被插入的行</li><li>在before触发器中，new中的值也可以被更新</li><li>对于auto_inrement列，new在执行前包含0，在执行后包含自动生成的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create trigger neworder after insert on orders</span><br><span class="line">for each row select NEW.order_num</span><br></pre></td></tr></table></figure></li></ul><h5 id="delete触发器"><a href="#delete触发器" class="headerlink" title="delete触发器"></a>delete触发器</h5><ul><li>引用一个名为<code>old</code>的虚拟表，访问被删除的行</li><li><code>old</code>中的值全部是只读的，不能更新</li></ul><h5 id="update触发器"><a href="#update触发器" class="headerlink" title="update触发器"></a>update触发器</h5><ul><li>在update触发器中，你可以引用一个<code>old</code>虚拟表访问以前的值，引用一个名为<code>new</code>的虚拟表访问新更新的值。</li><li><code>old</code>中的值全部是只读的，不能更新</li></ul><h3 id="事物处理"><a href="#事物处理" class="headerlink" title="事物处理"></a>事物处理</h3><h4 id="事物处理概要"><a href="#事物处理概要" class="headerlink" title="事物处理概要"></a>事物处理概要</h4><ul><li>事物处理可以用来维护数据库的完整性，它保证成批的MySQL指令要不完全执行，要不完全不执行。</li><li>常用术语：<ul><li>事务</li><li>回退</li><li>提交</li><li>保留点</li></ul></li></ul><h4 id="控制事物处理"><a href="#控制事物处理" class="headerlink" title="控制事物处理"></a>控制事物处理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start transaction</span><br></pre></td></tr></table></figure><h5 id="使用rollback来回退指令"><a href="#使用rollback来回退指令" class="headerlink" title="使用rollback来回退指令"></a>使用rollback来回退指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction</span><br><span class="line"></span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure><ul><li>事物处理用来管理insert,updata,delete语句</li></ul><h5 id="使用commit进行显示提交"><a href="#使用commit进行显示提交" class="headerlink" title="使用commit进行显示提交"></a>使用commit进行显示提交</h5><ul><li>一般的MySQl语句都是直接针对数据库执行和编写的，提交操作是自动进行的。</li><li>在事物处理板块，为了进行明确的提交，需要使用commit语句</li></ul><h5 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h5><ul><li>为了支回退部分的事物处理，必须能在事物处理块中合适的位置放置占位符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">savepoint delete1;</span><br><span class="line">rollback to dalete;</span><br></pre></td></tr></table></figure></li><li>释放保留点：保留点在事物处理完成后自动释放</li></ul><h5 id="更改默认行为"><a href="#更改默认行为" class="headerlink" title="更改默认行为"></a>更改默认行为</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0; 不自动提交更改</span><br></pre></td></tr></table></figure><ul><li>autocommit标志决定是否自动提交更改</li></ul><h3 id="全球化于本地化"><a href="#全球化于本地化" class="headerlink" title="全球化于本地化"></a>全球化于本地化</h3><h4 id="字符集与校对顺序"><a href="#字符集与校对顺序" class="headerlink" title="字符集与校对顺序"></a>字符集与校对顺序</h4><ul><li>字符集：字母与字符的集合·</li><li>编码：某个字符集成员的内部指令</li><li>校对：规定字符如何比较的指令</li></ul><h4 id="使用字符集与校对顺序"><a href="#使用字符集与校对顺序" class="headerlink" title="使用字符集与校对顺序"></a>使用字符集与校对顺序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show character set</span><br><span class="line">show collation</span><br></pre></td></tr></table></figure><h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql</span><br><span class="line">select user from user</span><br></pre></td></tr></table></figure><ul><li>获取所有的用户账号列表</li></ul><h4 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user name identified by &#x27;zx &#x27; </span><br><span class="line"></span><br><span class="line">set password for name = Password(&#x27;xxxx&#x27;) //修改用户口令</span><br></pre></td></tr></table></figure><h4 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show grants for xxx;</span><br><span class="line">grant select on database.* to name;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-MVCC</title>
      <link href="/2025/05/08/MVCC/"/>
      <url>/2025/05/08/MVCC/</url>
      
        <content type="html"><![CDATA[<h3 id="MVCC存储在哪里，作用是什么"><a href="#MVCC存储在哪里，作用是什么" class="headerlink" title="MVCC存储在哪里，作用是什么"></a>MVCC存储在哪里，作用是什么</h3><h4 id="MVCC是什么"><a href="#MVCC是什么" class="headerlink" title="MVCC是什么"></a>MVCC是什么</h4><ul><li>传统的数据库并发控制通常使用锁机制，在并发量高的情况下容易导致阻塞和性能下降。</li><li>读不阻塞写，写不阻塞读；为每个事务维护一个数据快照；创建新版本而不是覆盖。</li><li></li></ul><h4 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h4><p>好的，我们来详细解释一下 MVCC（多版本并发控制）的实现机制。</p><p>MVCC 的核心思想是<strong>维护数据的多个版本</strong>，使得读操作可以不阻塞写操作，写操作也不会阻塞读操作。它主要依赖于以下几个关键组成部分和机制：</p><ol><li><p><strong>事务 ID (Transaction ID)</strong></p><p>每个事务在开始时都会被分配一个唯一的、递增的事务 ID。这个 ID 在 MVCC 中用于标记数据是由哪个事务创建或修改的。</p></li><li><p><strong>数据行的版本链 (Version Chain)</strong></p><p>MVCC 数据库中的每一行数据通常都会有几个隐藏的列，用于记录该行的版本信息。这些隐藏列通常包括：</p><ul><li><strong>创建事务 ID (TrxId 或 <code>DB_TRX_ID</code>)：</strong> 记录创建该行数据的事务 ID。</li><li><strong>删除事务 ID (DelTrxId) 或 指向 Undo Log 的指针 (<code>DB_ROLL_PTR</code>)：</strong><ul><li>有些实现会记录删除该行数据的事务 ID。</li><li>更常见的实现（如 InnoDB）是使用一个回滚指针 (<code>DB_ROLL_PTR</code>) 指向 Undo Log 中记录了该行修改前数据的一条记录。通过这个指针，可以将同一逻辑行（同一条记录）的不同版本通过 Undo Log 连接起来，形成一个版本链。最新的版本位于链的头部，旧版本通过指针连接到 Undo Log 中。</li></ul></li></ul></li><li><p><strong>Undo Log (回滚日志)</strong></p><p>Undo Log 在 MVCC 中扮演着至关重要的角色：</p><ul><li><strong>存储旧版本数据：</strong> 当一个事务修改（UPDATE 或 DELETE）一行数据时，修改前的旧版本数据会被写入 Undo Log。</li><li><strong>构建版本链：</strong> 数据行中的回滚指针 (<code>DB_ROLL_PTR</code>) 正是指向 Undo Log 中的对应记录，从而构建起数据行的版本链。这个链条记录了该行数据从最初创建到当前版本的所有修改历史。</li><li><strong>支持回滚：</strong> 当事务需要回滚时，可以通过 Undo Log 中的记录将数据恢复到修改前的状态。</li><li><strong>支持快照读：</strong> 这是 MVCC 实现非阻塞读的关键。当一个事务需要读取数据时，它会根据自身的事务 ID 和可见性规则，沿着版本链在 Undo Log 中找到符合条件的、对当前事务可见的数据版本进行读取。</li></ul></li><li><p><strong>Read View (读视图)</strong></p><p>每个事务在启动时（或者根据隔离级别的不同，在执行特定语句时）会创建一个 Read View（或类似的机制，如快照时间戳）。Read View 记录了当前活跃（尚未提交）的事务 ID 列表。这个 Read View 是判断数据版本对当前事务是否可见的关键。</p><p>Read View 通常包含以下信息：</p><ul><li><code>m_ids</code>: 当前活跃的事务 ID 列表。</li><li><code>min_trx_id</code>: <code>m_ids</code> 列表中最小的事务 ID。</li><li><code>max_trx_id</code>: 在创建 Read View 时，系统中应该分配给下一个事务的 ID，即当前最大的事务 ID + 1。</li><li><code>creator_trx_id</code>: 创建这个 Read View 的事务的 ID。</li></ul></li><li><p><strong>可见性判断规则</strong></p><p>当一个事务尝试读取一行数据时，数据库会根据该事务的 Read View 和数据行版本（由创建事务 ID <code>DB_TRX_ID</code> 标记）来判断这个版本是否对当前事务可见。具体的判断规则会根据事务隔离级别（如 Read Committed 或 Repeatable Read）有所不同，但基本原则如下：</p><ul><li>如果数据行版本的创建事务 ID (<code>DB_TRX_ID</code>) <strong>小于</strong> Read View 中的 <code>min_trx_id</code>，表示这个版本是由一个在当前事务启动之前就已经提交的事务所创建，因此该版本对当前事务<strong>可见</strong>。</li><li>如果数据行版本的创建事务 ID (<code>DB_TRX_ID</code>) <strong>大于等于</strong> Read View 中的 <code>max_trx_id</code>，表示这个版本是由一个在当前事务启动之后才开始的事务所创建，因此该版本对当前事务<strong>不可见</strong>。</li><li>如果数据行版本的创建事务 ID (<code>DB_TRX_ID</code>) <strong>在</strong> Read View 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> <strong>之间</strong>：<ul><li>如果 <code>DB_TRX_ID</code> <strong>等于</strong> Read View 中的 <code>creator_trx_id</code>，表示这个版本是当前事务自己修改的，因此对当前事务<strong>可见</strong>。</li><li>如果 <code>DB_TRX_ID</code> <strong>在</strong> Read View 的 <code>m_ids</code> 列表 <strong>中</strong>，表示这个版本是由一个在当前事务启动时仍然活跃（但尚未提交）的事务所创建，因此对当前事务<strong>不可见</strong>。</li><li>如果 <code>DB_TRX_ID</code> <strong>不在</strong> Read View 的 <code>m_ids</code> 列表 <strong>中</strong>，表示这个版本是由一个在当前事务启动时已经提交的事务所创建（但其 ID 在 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间），因此对当前事务<strong>可见</strong>。</li></ul></li></ul><p>如果当前数据行版本对当前事务不可见，数据库会沿着 Undo Log 中的版本链向前查找更旧的版本，并对找到的每个版本重复上述可见性判断，直到找到一个可见的版本或者版本链的末端。</p></li></ol><p><strong>读写操作在 MVCC 中的处理：</strong></p><ul><li><strong>读操作：</strong> 当一个事务执行读操作（例如 <code>SELECT</code>）时，它会使用自己的 Read View，根据上述可见性判断规则，从数据行的版本链中找到对自身可见的最新版本进行读取。这个过程不涉及对数据的加锁，因此读操作不会阻塞写操作。</li><li><strong>写操作 (UPDATE&#x2F;DELETE)：</strong> 当一个事务执行写操作时，它首先会像读操作一样找到对自身可见的最新版本数据。然后，它会将该版本的旧数据写入 Undo Log，并在数据行中创建或修改隐藏列，记录自己的事务 ID 和指向 Undo Log 的指针。新的数据版本只对创建它的事务或者后续启动并满足可见性规则的事务可见。写操作通常仍然需要对要修改的数据行加锁（写锁），以防止其他事务同时修改同一行，但这个锁通常只持续到事务提交或回滚，且不会阻塞读操作。</li><li><strong>写操作 (INSERT)：</strong> 当一个事务插入一行新数据时，它会在数据行中记录自己的事务 ID 作为创建事务 ID。新插入的数据行对创建它的事务可见，对于其他事务，其可见性也遵循上述可见性判断规则。</li></ul><p><strong>过期版本的清理 (Purge)</strong></p><p>随着事务不断进行修改，数据行会产生越来越多的旧版本存储在 Undo Log 中。这些旧版本如果不再被任何活跃事务所需要，就需要被清理掉，以释放存储空间。这个清理过程通常由一个后台线程（Purge 线程）负责。Purge 线程会根据当前系统中所有活跃事务的 Read View，确定哪些 Undo Log 中的旧版本数据已经不再可能被任何事务读取，然后进行物理删除。长事务会持有旧版本的 Read View，从而阻止对旧版本数据的清理，可能导致 Undo Log 不断增长。</p><p><strong>总结：</strong></p><p>MVCC 通过为每个事务提供一个数据快照，并利用事务 ID、数据行版本链和 Undo Log 来存储和管理数据的多个版本。通过 Read View 和可见性判断规则，MVCC 使得读操作可以并发进行而不会被写操作阻塞，显著提高了数据库的并发性能和吞吐量，同时提供了良好的事务隔离性（通常是 Snapshot Isolation 或 Read Committed）。</p><h4 id="MVCC存储在哪里"><a href="#MVCC存储在哪里" class="headerlink" title="MVCC存储在哪里"></a>MVCC存储在哪里</h4><ul><li><p><strong>数据行中的隐藏列：</strong> InnoDB 为每行数据添加了几个隐藏的系统列，其中与 MVCC 密切相关的主要有两个：</p><ul><li><code>DB_TRX_ID</code>：记录了最近一次修改（插入或更新）该行的事务 ID。删除在内部也被视为一种更新，会设置一个特殊的位标记。</li><li><code>DB_ROLL_PTR</code>：这是一个回滚指针，指向 Undo Log 中的一条记录。如果该行是被更新的，Undo Log 记录包含了重建更新前行内容所需的信息。通过这个指针和 Undo Log，可以找到该行的上一个版本。</li></ul></li><li><p><strong>Undo Log（回滚日志）：</strong></p><ul><li><strong>作用：</strong> Undo Log 是存储旧版本数据的地方。每当事务修改数据时，旧版本的数据会被写入 Undo Log。</li><li><strong>存储位置：</strong> Undo Log 存储在称为回滚段（rollback segment）的数据结构中，这些回滚段位于 Undo 表空间。Undo 表空间可以是共享的（在 <code>ibdataX</code> 文件中）或者独立的文件。</li><li><strong>MVCC 的依赖：</strong> 当一个事务需要读取某个数据行的旧版本时（根据事务自身的快照时间戳和数据行中的 <code>DB_TRX_ID</code> 判断），它会利用 <code>DB_ROLL_PTR</code> 沿着 Undo Log 的链条找到并重构出符合其可见性条件的旧版本数据。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-隔离语句</title>
      <link href="/2025/05/08/MYSQL%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E8%AF%AD%E5%8F%A5/"/>
      <url>/2025/05/08/MYSQL%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。<br>![[Pasted image 20250509171209.png|500]]</li></ul><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MySQL&gt; SELECT @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><p>从上面对 SQL 标准定义了四个隔离级别的介绍可以看出，标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的。</p><p>但是！InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong>：由 MVCC 机制来保证不出现幻读。</li><li><strong>当前读</strong>：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li></ul><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ</strong> 并不会有任何性能损失。</p><p>InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。</p><p>《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章这样写到：</p><blockquote><p>InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-三大日志</title>
      <link href="/2025/05/08/%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/05/08/%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Redo-Log-重做日志"><a href="#1-Redo-Log-重做日志" class="headerlink" title="1. Redo Log (重做日志)"></a>1. Redo Log (重做日志)</h3><ul><li><strong>作用：</strong> Redo Log 是 <strong>InnoDB 存储引擎特有的日志</strong>，用于实现事务的 <strong>持久性（Durability）</strong>。它的主要目的是<strong>确保事务在提交后，即使发生数据库崩溃，数据也不会丢失</strong>。</li><li><strong>记录内容：</strong> 它记录的是<strong>数据页（data page）上的物理修改</strong>，即“在某个数据页的某个偏移量上修改了什么值”。例如，“将第100页的第20字节到24字节从X改为Y”。</li><li><strong>工作原理（WAL - Write-Ahead Logging）：</strong><ol><li>当事务提交时，MySQL 不会立即将所有修改的数据页从内存（Buffer Pool）刷写到磁盘。因为数据页是随机 I&#x2F;O，效率较低。</li><li>相反，它会先将事务对数据页的修改记录到 Redo Log 中。Redo Log 是<strong>顺序写入</strong>的，这比随机 I&#x2F;O 快得多。</li><li>Redo Log 会先写入内存中的 Redo Log Buffer，然后根据配置（<code>innodb_flush_log_at_trx_commit</code> 等）周期性地刷写到磁盘上的 Redo Log 文件。</li><li><strong>先写日志，再写数据</strong>。只要 Redo Log 记录了事务的修改并刷写到了磁盘，即使数据页还没来得及刷到磁盘数据库就崩溃了，系统也可以在重启时通过重放（Redo）Redo Log 中的记录来恢复数据，确保事务的完整性。</li></ol></li><li><strong>恢复（Crash Recovery）：</strong> 数据库重启时，会检查 Redo Log。如果发现有些事务的 Redo Log 已经提交但对应的数据页还没有写入磁盘，就会重放这些 Redo Log 来恢复数据到崩溃前的状态。</li><li><strong>文件形式：</strong> 通常是循环写入的固定大小文件组（如 <code>ib_logfile0</code>, <code>ib_logfile1</code>）。</li></ul><h3 id="2-Binlog-二进制日志"><a href="#2-Binlog-二进制日志" class="headerlink" title="2. Binlog (二进制日志)"></a>2. Binlog (二进制日志)</h3><ul><li><strong>作用：</strong> Binlog 是 <strong>MySQL Server 层（而不是存储引擎层）的日志</strong>，因此它不限于 InnoDB 存储引擎，所有存储引擎都会产生 Binlog。它的主要用途是：<ol><li><strong>数据复制（Replication）&#x2F;主从同步：</strong> 主数据库将 Binlog 传输给从数据库，从数据库重放 Binlog 来保持数据同步。</li><li><strong>数据恢复（Point-in-Time Recovery）：</strong> 可以根据 Binlog 将数据库恢复到某个特定的时间点，例如，在误操作后恢复到误操作之前的状态。</li><li><strong>审计：</strong> 记录数据库的所有更改操作，用于安全审计。</li></ol></li><li><strong>记录内容：</strong> 它记录的是<strong>逻辑操作</strong>，即 SQL 语句的逻辑修改内容，例如“对表 A 插入一行数据，值为 (1, ‘张三’)”或者“将表 B 中 id&#x3D;5 的记录的 name 字段改为 ‘李四’”。</li><li><strong>日志格式：</strong><ul><li><strong>Statement 格式：</strong> 记录 SQL 语句本身（例如 <code>INSERT ...</code>, <code>UPDATE ...</code>）。</li><li><strong>Row 格式：</strong> 记录每一行数据的具体修改（例如，某行数据修改前的值和修改后的值）。这是更推荐和常用的一种格式，因为它更稳定，避免了 Statement 格式可能存在的“非确定性”问题。</li><li><strong>Mixed 格式：</strong> 混合使用 Statement 和 Row 格式。</li></ul></li><li><strong>刷写机制：</strong> 事务提交时，Binlog 也会被写入磁盘。通常会在事务提交的最后阶段写入。</li><li><strong>文件形式：</strong> 一系列按时间顺序递增的文件（如 <code>mysql-bin.000001</code>, <code>mysql-bin.000002</code>）。</li></ul><h3 id="3-Undo-Log-回滚日志"><a href="#3-Undo-Log-回滚日志" class="headerlink" title="3. Undo Log (回滚日志)"></a>3. Undo Log (回滚日志)</h3><ul><li><strong>作用：</strong> Undo Log 也是 <strong>InnoDB 存储引擎特有的日志</strong>，用于实现事务的 <strong>原子性（Atomicity）</strong> 和 <strong>一致性（Consistency）</strong>，以及 **MVCC (Multi-Version Concurrency Control) **。</li><li><strong>记录内容：</strong> 它记录的是<strong>数据被修改前的状态</strong>。例如，如果一条记录从值 A 修改为值 B，Undo Log 会记录“将值 B 改回值 A 的操作”。这可以理解为 Redo Log 的逆操作。</li><li><strong>工作原理：</strong><ol><li>当事务修改数据时，在修改数据之前，会将数据的旧版本写入 Undo Log。</li><li>如果事务需要<strong>回滚（ROLLBACK）</strong>，系统会读取 Undo Log 中的记录，根据这些记录将数据恢复到事务开始前的状态，从而保证原子性。</li><li><strong>MVCC</strong>：Undo Log 也是实现 MVCC 的关键。当一个事务读取数据时，如果该数据正在被另一个事务修改，读取事务可以通过 Undo Log 找到该数据修改前的版本（快照），从而实现不加锁的读操作，提高并发性能。每个事务都会看到它自己启动时的数据视图。</li></ol></li><li><strong>文件形式：</strong> Undo Log 存储在共享表空间（System Tablespace）或独立的 Undo Tablespace 文件中。</li><li><strong>生命周期：</strong> 事务提交后，Undo Log 不会立即删除，因为 MVCC 可能还需要它来提供旧版本的数据视图。当不再有任何事务需要它时，它才会被清理。</li></ul><h3 id="三者之间的关系和区别："><a href="#三者之间的关系和区别：" class="headerlink" title="三者之间的关系和区别："></a>三者之间的关系和区别：</h3><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>特性</strong></td><td><strong>Redo Log (重做日志)</strong></td><td><strong>Binlog (二进制日志)</strong></td><td><strong>Undo Log (回滚日志)</strong></td></tr><tr><td><strong>层级</strong></td><td>InnoDB 存储引擎层</td><td>MySQL Server 层（独立于存储引擎）</td><td>InnoDB 存储引擎层</td></tr><tr><td><strong>目的</strong></td><td><strong>持久性</strong>：确保事务提交后数据不丢失（崩溃恢复）</td><td><strong>复制、恢复、审计</strong>：主从同步、时间点恢复</td><td><strong>原子性、一致性</strong>：事务回滚、<strong>MVCC</strong></td></tr><tr><td><strong>记录</strong></td><td><strong>物理修改</strong>：某个数据页的某个偏移量被修改</td><td><strong>逻辑操作</strong>：SQL 语句或行数据更改的逻辑过程</td><td><strong>逻辑修改的逆操作</strong>：数据修改前的状态（如何回滚）</td></tr><tr><td><strong>写入</strong></td><td>顺序写入</td><td>顺序写入</td><td>随机写入（为了记录旧版本数据）</td></tr><tr><td><strong>刷盘</strong></td><td>事务提交前刷盘（WAL）</td><td>事务提交后刷盘</td><td>事务提交时写入，但清理延迟</td></tr><tr><td><strong>作用对象</strong></td><td>数据页</td><td>整个数据库操作</td><td>数据行（旧版本）</td></tr></tbody></table><p>在面试中，能够清晰地解释这三种日志的作用、原理和相互关系，将很好地展示你对 MySQL 数据库事务和数据一致性机制的深刻理解。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-搜索引擎</title>
      <link href="/2025/05/08/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/05/08/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>MySQL中，InnoDB和MyISAM是两种最常用的存储引擎，它们在设计和功能上有显著的区别。理解这些区别对于选择适合特定应用场景的存储引擎至关重要。以下是它们之间主要的区别：</p><p><strong>1. 事务支持 (Transaction Support):</strong></p><ul><li><strong>InnoDB:</strong> 支持事务，符合ACID（原子性、一致性、隔离性、持久性）特性。这意味着在InnoDB表中进行操作时，可以将一系列操作组合成一个独立的逻辑单元，要么全部成功提交，要么全部失败回滚。这对于需要保证数据一致性和完整性的应用（如金融交易）至关重要。</li><li><strong>MyISAM:</strong> 不支持事务。每个操作都是独立的，无法回滚。如果在操作过程中发生错误或系统崩溃，可能导致数据不一致或损</li></ul><p><strong>4. 崩溃恢复 (Crash Recovery):</strong></p><ul><li><strong>InnoDB:</strong> 具有强大的崩溃恢复能力。它使用事务日志（redo log 和 undo log）来记录所有修改，即使在系统崩溃后，也可以通过回放日志来恢复数据到崩溃前的状态，最大程度地保证数据不丢失和一致性。</li><li><strong>MyISAM:</strong> 崩溃后恢复能力较弱。如果系统在写操作过程中崩溃，表可能损坏，需要进行手动修复（如使用 <code>myisamchk</code> 工具），且存在数据丢失的风险。</li></ul><p><strong>5. 索引 (Indexing):</strong></p><ul><li><strong>InnoDB:</strong> 使用聚簇索引（Clustered Index）。数据行存储在主键索引的叶子节点中。这意味着数据和主键索引是紧密S耦合的，通过主键查询效率很高。非主键索引存储的是主键值，通过非主键索引查询需要两次查找。</li><li><strong>MyISAM:</strong> 使用非聚簇索引（Non-clustered Index）。索引和数据是分开存储的。索引文件中存储的是指向数据文件中数据行的指针。主键索引和其他索引没有本质区别。</li></ul><p><strong>2. 锁定机制 (Locking):</strong></p><ul><li><strong>InnoDB:</strong> 实现行级锁定。当一个事务锁定一行数据时，其他事务仍然可以访问同一张表中的其他行。这大大提高了在高并发读写场景下的性能。</li><li><strong>MyISAM:</strong> 实现表级锁定。当一个进程对表进行写操作时，整个表都会被锁定，其他进程必须等待写操作完成后才能访问该表。这在读操作频繁但写操作较少的场景下可能表现尚可，但在高并发写操作下会导致严重的性能瓶颈。</li></ul><p><strong>3. 外键约束 (Foreign Key Constraints):</strong></p><ul><li><strong>InnoDB:</strong> 支持外键。通过定义外键，可以维护表之间的关联关系，并确保数据的引用完整性。当父表中的记录被删除或更新时，可以根据定义的外键规则（如CASCADE, SET NULL, RESTRICT）自动更新或限制子表中的相关记录。</li><li><strong>MyISAM:</strong> 不支持外键。表之间的关联关系需要在应用层面进行维护。</li></ul><p><strong>6. 性能 (Performance):</strong></p><ul><li><strong>读操作为主的场景:</strong> 在纯粹的读操作场景下，MyISAM 的表级锁定可能更快，因为它管理锁的开销较低。<code>COUNT(*)</code> 查询在MyISAM中通常也更快，因为MyISAM在表头保存了总行数。</li><li><strong>写操作为主或混合读写的场景:</strong> InnoDB 由于其行级锁定和更好的并发处理能力，在高并发写操作或混合读写场景下通常表现更好。</li><li><strong>大数据量:</strong> 对于非常大的数据量，InnoDB 的性能通常优于 MyISAM，尤其是在需要频繁进行更新和删除操作时。</li></ul><p><strong>7. 存储空间 (Storage Space):</strong></p><ul><li><strong>MyISAM:</strong> 通常比InnoDB占用更少的磁盘空间，因为它的存储结构相对简单，且不支持事务日志等。</li><li><strong>InnoDB:</strong> 需要额外的空间来存储事务日志和undo信息，因此通常比MyISAM占用更多的磁盘空间。</li></ul><p><strong>8. 其他特性:</strong></p><ul><li><strong>InnoDB:</strong> 支持表空间（Tablespaces），可以将不同的表存储在不同的文件或设备上。支持热备份。</li><li><strong>MyISAM:</strong> 支持全文索引（FULLTEXT index，虽然新版本的InnoDB也支持）。支持空间数据类型（Spatial Data Types）和索引（新版本的InnoDB也已支持）。</li></ul><p><strong>总结表格：</strong></p><table><thead><tr><th align="left">特性</th><th align="left">InnoDB</th><th align="left">MyISAM</th></tr></thead><tbody><tr><td align="left">事务支持</td><td align="left">支持 (ACID)</td><td align="left">不支持</td></tr><tr><td align="left">锁定粒度</td><td align="left">行级锁定</td><td align="left">表级锁定</td></tr><tr><td align="left">外键约束</td><td align="left">支持</td><td align="left">不支持</td></tr><tr><td align="left">崩溃恢复</td><td align="left">强大，数据丢失风险低</td><td align="left">较弱，可能需要手动修复，有数据丢失风险</td></tr><tr><td align="left">索引类型</td><td align="left">聚簇索引 (Primary Key) + 非聚簇索引</td><td align="left">非聚簇索引</td></tr><tr><td align="left">性能 (读)</td><td align="left">在高并发读写下表现优秀</td><td align="left">纯读操作下可能更快</td></tr><tr><td align="left">性能 (写)</td><td align="left">在高并发写操作下表现优秀</td><td align="left">写操作会锁定整表，性能受限</td></tr><tr><td align="left">存储空间</td><td align="left">占用空间相对较大</td><td align="left">占用空间相对较小</td></tr><tr><td align="left">全文索引</td><td align="left">新版本支持</td><td align="left">支持</td></tr><tr><td align="left">空间数据类型</td><td align="left">新版本支持</td><td align="left">支持</td></tr></tbody></table><p><strong>选择建议：</strong></p><ul><li>如果你的应用需要事务支持、数据完整性、高并发读写性能，或者需要利用外键来维护数据关系，那么 <strong>InnoDB</strong> 是更好的选择。现代的Web应用和企业级应用绝大多数都推荐使用InnoDB。</li><li>如果你的应用以读操作为主，写操作非常少，且对事务和数据完整性要求不高，或者需要利用旧版本MyISAM特有的全文索引功能，那么可以考虑 <strong>MyISAM</strong>。但需要注意其在高并发写和崩溃恢复方面的不足。</li></ul><p>在大多数情况下，尤其是对于新的应用开发，推荐优先考虑使用InnoDB引擎。自MySQL 5.5版本开始，InnoDB已经成为MySQL的默认存储引擎。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-索引失效</title>
      <link href="/2025/05/08/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
      <url>/2025/05/08/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SQL-写法导致的失效"><a href="#一、SQL-写法导致的失效" class="headerlink" title="一、SQL 写法导致的失效"></a>一、SQL 写法导致的失效</h2><ol><li><p><strong>列上使用函数或表达式</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> <span class="built_in">UPPER</span>(name) <span class="operator">=</span> <span class="string">&#x27;JACK&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">DATE</span>(create_time) <span class="operator">=</span> <span class="string">&#x27;2025‑06‑18&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>原因：函数或表达式会在每行数据上执行运算，无法利用原始索引结构。</li></ul></li><li><p><strong>前缀模糊匹配</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;%zhang&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>原因：前置通配符让引擎无法定位索引树的起始位置，只能全表扫描。</li></ul></li><li><p><strong>隐式类型转换</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>      <span class="comment">-- user_id 为整型</span></span><br></pre></td></tr></table></figure><ul><li>原因：数据库会对列或常量做隐式转换，导致索引字段值“失配”，不能走索引。</li></ul></li><li><p><strong>OR 条件跨列或无关联</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">OR</span> gender <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>原因：多个列上的 OR 可能导致无法复用单列索引，除非有专门的复合索引并且满足左前缀原则。</li></ul></li><li><p><strong>不等（&lt;&gt;、!&#x3D;、NOT IN、NOT LIKE）条件</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> status <span class="operator">&lt;&gt;</span> <span class="string">&#x27;ACTIVE&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li>原因：此类条件通常无法精准定位范围，只能全表或全分片扫描。</li></ul></li></ol><hr><h2 id="二、复合索引（联合索引）相关"><a href="#二、复合索引（联合索引）相关" class="headerlink" title="二、复合索引（联合索引）相关"></a>二、复合索引（联合索引）相关</h2><ol><li><p><strong>未遵循最左前缀原则</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_ab <span class="keyword">ON</span> t(a, b);</span><br><span class="line"><span class="comment">-- 下面的查询无法走 idx_ab</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li>只有在 SQL 中按照 <code>(a,…)</code> 或 <code>(a, b)</code> 的顺序使用条件，才能命中该索引。</li></ul></li><li><p><strong>范围查询后丢失后续列索引</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>对 b 进行范围查询后，c 列即便有条件，也不会再走联合索引的 c 部分。</li></ul></li><li><p><strong>排序／分组字段与索引顺序不匹配</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> b, a   <span class="comment">-- 索引是 (a, b)</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c, a   <span class="comment">-- 索引顺序需和 GROUP BY 一致</span></span><br></pre></td></tr></table></figure><ul><li>索引顺序要与 ORDER BY&#x2F;GROUP BY 的列顺序完全一致，才能进行 “索引排序&#x2F;分组” 优化。</li></ul></li></ol><hr><h2 id="三、大数据量与统计失真"><a href="#三、大数据量与统计失真" class="headerlink" title="三、大数据量与统计失真"></a>三、大数据量与统计失真</h2><ol><li><p><strong>低基数列建索引</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_gender <span class="keyword">ON</span> t(gender);</span><br></pre></td></tr></table></figure><ul><li>性别一般只有两三个取值（低选择性），优化效果有限，优化器可能直接选择全表扫描。</li></ul></li><li><p><strong>旧统计信息未更新</strong></p><ul><li>数据量变化后，如果没有及时 <code>ANALYZE TABLE</code>，优化器对索引选择不准确，可能误判走全表扫描。</li></ul></li></ol><hr><h2 id="四、其它特殊场景"><a href="#四、其它特殊场景" class="headerlink" title="四、其它特殊场景"></a>四、其它特殊场景</h2><ol><li><p><strong>UPDATE&#x2F;DELETE 带子查询或 JOIN</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t1 </span><br><span class="line">  <span class="keyword">SET</span> … </span><br><span class="line"><span class="keyword">WHERE</span> t1.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> …);</span><br></pre></td></tr></table></figure><ul><li>子查询或多表关联，若没有优化得当，会失去单表索引优势。</li></ul></li><li><p><strong>OFFSET 大分页</strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li>虽然有索引排序，但大量偏移会累积扫描成本，表现类似全表扫描。</li></ul></li><li><p><strong>函数索引／虚拟列未使用</strong></p><ul><li>在某些场景下，可通过为常用表达式（如 <code>DATE(create_time)</code>）创建函数索引或虚拟列，再对该列建索引来规避函数失效问题。</li></ul></li></ol><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p><strong>写 SQL 时</strong>：避免在索引列上做函数、表达式、前缀模糊、隐式转换和复杂 OR&#x2F;NOT 条件。</p></li><li><p><strong>设计索引时</strong>：遵守最左前缀原则，考虑查询排序／分组场景；低选择性列慎用。</p></li><li><p><strong>运维维护</strong>：定期更新统计信息，监控执行计划；在必要时引入函数索引或虚拟列。</p></li></ul><p>掌握这些常见“索引失效”场景，并能结合具体实例说明，你的回答就既有深度也具备实战价值。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-索引</title>
      <link href="/2025/05/08/%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2025/05/08/%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="AI相关提问"><a href="#AI相关提问" class="headerlink" title="AI相关提问"></a>AI相关提问</h2><p><strong>基础概念类：</strong></p><ol><li><p><strong>什么是数据库索引？为什么要使用索引？</strong></p><ul><li><strong>解答：</strong> 数据库索引是一种特殊的数据结构（通常是 B-Tree 或 B+Tree），它存储着表中一列或多列的值，并关联着这些值对应的数据行的物理位置或主键信息。</li><li>使用索引的目的是为了<strong>加快从表中检索数据的速度</strong>。没有索引时，数据库可能需要扫描整个表（全表扫描）来找到匹配的数据，这在表很大时效率非常低。有了索引，数据库可以直接根据索引结构快速定位到目标数据行，就像书的目录一样。</li></ul></li><li><p><strong>索引的主要作用是什么？它解决了什么问题？</strong></p><ul><li><strong>解答：</strong> 索引的主要作用是<strong>显著提升数据库查询（SELECT）的性能</strong>，特别是带有 <code>WHERE</code> 条件过滤、<code>JOIN</code> 表连接、<code>ORDER BY</code> 排序和 <code>GROUP BY</code> 分组的查询。</li><li>它解决了在大数据量表中进行数据查找效率低下的问题，避免了昂贵的全表扫描操作。</li></ul></li><li><p><strong>使用索引有什么优点和缺点？</strong></p><ul><li><strong>解答：</strong><ul><li><strong>优点：</strong><ul><li>大幅提高数据检索速度，减少数据库的查询响应时间。</li><li>在进行数据排序和分组时，可以减少或避免额外的排序开销。</li><li>在连接（JOIN）操作中，可以提高连接的效率。</li></ul></li><li><strong>缺点：</strong><ul><li><strong>占用磁盘空间：</strong> 索引本身是需要存储的。</li><li><strong>降低写操作性能：</strong> 当表中数据进行 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 操作时，不仅需要修改表中的数据，还需要同步更新相关的索引结构，这增加了额外的开销，导致写操作变慢。</li><li><strong>创建和维护成本：</strong> 创建索引需要时间，并且随着数据的修改，索引可能需要定期维护（如重建）以保持其效率。</li></ul></li></ul></li></ul></li></ol><p><strong>索引类型与原理类：</strong></p><ol start="4"><li><p><strong>数据库中常用的索引数据结构有哪些？请简述它们的工作原理。</strong></p><ul><li><strong>解答：</strong><ul><li><strong>B-Tree（或 B+Tree）：</strong> 这是关系型数据库中最常用的索引结构。它是一种平衡树，能够保持数据有序，支持高效的查找、范围查询、插入和删除操作。其特点是树的每个节点可以存储多个关键字和子节点的指针，树的高度较低，适合磁盘存储（减少磁盘I&#x2F;O）。</li><li><strong>Hash Index：</strong> 基于哈希表实现。通过对索引列的值计算哈希码，并映射到哈希表中的桶，桶中存储指向数据行的指针。适用于等值查询（<code>=</code>），查找速度极快（理论上 O(1)），但不适用于范围查询、排序或模糊匹配。</li></ul></li></ul></li><li><p><strong>B-Tree 和 B+Tree 有什么区别？数据库索引为什么多用 B+Tree？</strong></p><ul><li><strong>解答：</strong><ul><li><strong>区别：</strong><ul><li><strong>数据存储位置：</strong> 在 B-Tree 中，数据（或指向数据的指针）可以存储在树的任何节点。在 B+Tree 中，数据（或指向数据的指针）只存储在叶子节点，非叶子节点只存储键值用于导航。</li><li><strong>叶子节点连接：</strong> B+Tree 的所有叶子节点构成一个有序链表，可以方便地进行范围扫描。B-Tree 的叶子节点之间通常没有链表连接。</li></ul></li><li><strong>数据库索引多用 B+Tree 的原因：</strong><ul><li><strong>更适合磁盘 I&#x2F;O：</strong> B+Tree 的非叶子节点只存储键，相同大小的节点可以存储更多的键，因此树的高度更低，减少了磁盘查找次数。</li><li><strong>范围查询效率高：</strong> 叶子节点的链表结构使得范围查询（如 <code>WHERE col BETWEEN 10 AND 20</code>）非常高效，只需找到范围的起点，然后沿着链表顺序遍历即可。</li><li><strong>全表扫描效率高：</strong> 如果需要进行全表扫描，可以直接遍历 B+Tree 叶子节点链表，比 B-Tree 方便。</li></ul></li></ul></li></ul></li><li><p><strong>什么是聚集索引（Clustered Index）？什么是非聚集索引（Non-clustered Index）？它们有什么区别？</strong></p><ul><li><strong>解答：</strong><ul><li><strong>聚集索引：</strong> 定义了表中数据行的物理存储顺序。数据的物理存储顺序与索引的逻辑顺序一致。一个表<strong>最多只能有一个</strong>聚集索引，因为数据行只能按照一种物理顺序存放。通常主键会自动创建聚集索引（如果表没有其他聚集索引）。</li><li><strong>非聚集索引：</strong> 一个独立于数据行的结构（通常是 B+Tree）。它的叶子节点存储索引列的值以及指向实际数据行的“书签”（例如，数据行的物理地址或主键值，取决于数据库实现）。数据行的物理存储顺序与非聚集索引的逻辑顺序无关。一个表可以有<strong>多个</strong>非聚集索引。</li><li><strong>区别总结：</strong><ul><li>数量：聚集索引最多一个，非聚集索引可以多个。</li><li>物理顺序：聚集索引决定数据物理顺序，非聚集索引不决定。</li><li>叶子节点内容：聚集索引叶子节点是数据行本身，非聚集索引叶子节点是索引值 + 指向数据行的指针。</li><li>数据访问：通过聚集索引查找数据，直接定位到数据行。通过非聚集索引查找数据，首先通过索引找到指向数据行的指针，然后再去查找数据行（称为“回表查询”）。</li></ul></li></ul></li></ul></li><li><p><strong>什么是哈希索引（Hash Index）？它的优缺点是什么？适用于什么场景？</strong></p><ul><li><strong>解答：</strong><ul><li><strong>概念：</strong> 基于哈希表实现，将索引列值通过哈希函数计算哈希码，并存储在一个哈希表结构中，每个哈希值对应一个或多个数据行的指针。</li><li><strong>优点：</strong> 在进行等值查询（<code>=</code>）时，查找速度非常快，平均时间复杂度 O(1)。</li><li><strong>缺点：</strong><ul><li><strong>不支持范围查询、排序、模糊匹配</strong>。</li><li>哈希冲突可能影响性能。</li><li>不支持索引列的函数计算。</li><li>通常只支持等值比较。</li></ul></li><li><strong>适用场景：</strong> 仅需要执行等值查询，数据不需要排序的场景。例如，某些 NoSQL 数据库或特定存储引擎（如 MySQL 的 MEMORY 引擎）会使用哈希索引。</li></ul></li></ul></li><li><p><strong>什么是全文索引（Full-text Index）？</strong></p><ul><li><strong>解答：</strong> 全文索引是为大型文本数据（如文章内容、评论等）设计的特殊索引。它对文本进行分词、过滤停用词、词干提取等处理后建立索引，用于高效地在文本内容中进行关键词搜索、短语搜索、模糊搜索等。</li></ul></li><li><p><strong>什么是覆盖索引（Covering Index）？它的好处是什么？</strong></p><ul><li><strong>解答：</strong> 覆盖索引是指一个非聚集索引，它包含了查询语句中 <code>SELECT</code> 列表和 <code>WHERE</code> 子句等条件中所有需要的列。</li><li><strong>好处：</strong> 当查询可以使用覆盖索引时，数据库只需要遍历这个索引结构就可以获取所有需要的数据，而<strong>无需再回到表中去查找实际的数据行</strong>（避免了“回表查询”）。这极大地减少了磁盘 I&#x2F;O 操作，从而显著提高查询性能。</li></ul></li></ol><p><strong>索引设计与使用类：</strong></p><ol start="10"><li><p><strong>应该在哪些列上创建索引？有哪些选择索引列的原则？</strong></p><ul><li><strong>解答：</strong><ul><li><strong>原则：</strong><ul><li>经常出现在 <code>WHERE</code> 子句中作为过滤条件的列。</li><li>经常出现在 <code>JOIN</code> 连接条件中的列。</li><li>经常出现在 <code>ORDER BY</code> 或 <code>GROUP BY</code> 子句中用于排序或分组的列。</li><li>具有较高基数（列中不重复值的数量占总行数的比例高）的列，这样索引才能有效地过滤数据。</li><li>作为表的主键（Primary Key）或唯一键（Unique Key）的列，数据库会自动创建索引（通常是聚集索引或唯一非聚集索引）。</li></ul></li></ul></li></ul></li><li><p><strong>不应该在哪些列上创建索引？</strong></p><ul><li><strong>解答：</strong><ul><li><strong>低基数（Low Cardinality）的列：</strong> 例如性别、状态、布尔值等，这些列的不同值很少。在这种情况下，使用索引进行过滤可能只能排除很少一部分数据，优化器可能认为全表扫描更快。</li><li><strong>更新非常频繁的列：</strong> 每次更新都需要维护索引，增加写操作的开销。</li><li><strong>大型文本（BLOB&#x2F;TEXT）列的全部内容：</strong> 如果需要对文本内容搜索，应考虑使用全文索引，而不是普通索引。对这些列建立索引通常只对列的前缀有效。</li></ul></li></ul></li><li><p><strong>什么是联合索引（Composite Index 或 Multi-column Index）？如何选择联合索引中列的顺序？</strong></p><ul><li><strong>解答：</strong><ul><li><strong>联合索引：</strong> 在表的多个列上创建的索引。例如，<code>CREATE INDEX idx_name ON table_name (col1, col2, col3);</code></li><li><strong>列的顺序选择：</strong> 联合索引的列顺序非常重要，因为它遵循<strong>最左前缀原则</strong>。通常将<strong>最常用于过滤、范围查询或排序的列放在前面</strong>。如果 <code>col1</code> 经常单独使用，并且 <code>(col1, col2)</code> 经常一起使用，那么将 <code>col1</code> 放在 <code>col2</code> 前面是一个好的选择。</li></ul></li></ul></li><li><p><strong>解释最左前缀原则。</strong></p><ul><li><strong>解答：</strong> 对于联合索引 <code>(col1, col2, col3)</code>，索引会按照 <code>col1</code> 先排序，在 <code>col1</code> 相同的情况下再按照 <code>col2</code> 排序，以此类推。最左前缀原则意味着数据库可以利用这个索引来支持基于索引<strong>最左边连续的列</strong>的查询。</li><li>例如，索引 <code>(a, b, c)</code> 可以有效地用于以下查询条件：<ul><li><code>WHERE a = 1</code></li><li><code>WHERE a = 1 AND b = 2</code></li><li><code>WHERE a = 1 AND b = 2 AND c = 3</code></li><li><code>WHERE a &gt; 1</code> (范围查询，可能会扫描部分索引)</li><li><code>WHERE a = 1 ORDER BY b</code> (如果索引覆盖了 <code>b</code>)</li></ul></li><li>但它<strong>不能直接</strong>用于以下查询条件（或者只能使用索引的一部分，甚至完全不使用索引）：<ul><li><code>WHERE b = 2</code> (没有最左边的 <code>a</code>)</li><li><code>WHERE c = 3</code> (没有最左边的 <code>a</code> 和 <code>b</code>)</li><li><code>WHERE b = 2 AND c = 3</code></li></ul></li></ul></li><li><p><strong>创建索引后，如何判断查询是否使用了索引？如何查看查询的执行计划？</strong></p><ul><li><strong>解答：</strong> 可以通过数据库提供的<strong>执行计划</strong>（Execution Plan）工具来分析查询是否使用了索引以及如何使用。</li><li>不同的数据库有不同的命令或工具：<ul><li><strong>MySQL:</strong> 在查询语句前加上 <code>EXPLAIN</code> 关键字，例如 <code>EXPLAIN SELECT * FROM users WHERE username = &#39;test&#39;;</code> 查看输出结果，关注 <code>type</code> (如 <code>ref</code>, <code>range</code>, <code>index</code>, <code>ALL</code> - 全表扫描), <code>possible_keys</code>, <code>key</code> (实际使用的索引), <code>key_len</code>, <code>rows</code>, <code>Extra</code> (如 <code>Using index</code>, <code>Using where</code>, <code>Using filesort</code>) 等信息。</li><li><strong>SQL Server:</strong> 在查询分析器中执行查询后，选择“显示实际执行计划”或“显示估计执行计划”。图形化的执行计划会直观地显示操作类型（如 Index Seek, Index Scan, Table Scan）以及使用的索引。</li></ul></li><li>通过分析执行计划，可以确认索引是否生效，以及索引的使用效率。</li></ul></li><li><p><strong>什么是索引扫描（Index Scan）和全表扫描（Table Scan）？什么是索引查找（Index Seek）？</strong></p><ul><li><strong>解答：</strong><ul><li><strong>全表扫描 (Table Scan):</strong> 数据库逐行读取整个表的数据来寻找符合条件的记录。效率最低，尤其是在大表上。</li><li><strong>索引扫描 (Index Scan):</strong> 数据库遍历索引中的一部分或全部条目来找到匹配的记录。通常比全表扫描快，尤其当索引是覆盖索引时。范围查询 (<code>BETWEEN</code>, <code>&gt;</code>) 经常会用到索引扫描。</li><li><strong>索引查找 (Index Seek):</strong> 数据库通过索引结构（如 B+Tree 的导航）直接精确地定位到索引中的一个或一小部分条目，然后根据这些条目找到对应的数据行。这是最高效的索引使用方式，通常用于等值查询或小范围查询。</li></ul></li></ul></li><li><p><strong>在哪些情况下索引可能不会被使用？</strong></p><ul><li><strong>解答：</strong><ul><li>查询没有使用联合索引的最左前缀。</li><li>在索引列上使用了函数或进行了计算（如 <code>WHERE YEAR(date_col) = 2023</code>）。</li><li><code>LIKE</code> 语句使用了前导通配符（如 <code>WHERE name LIKE &#39;%keyword&#39;</code>），这使得无法利用索引的有序性。</li><li>使用了否定条件，如 <code>!=</code>, <code>NOT IN</code> （优化器可能会选择全表扫描）。</li><li>数据库统计信息过期，优化器未能选择最佳执行计划。</li><li>表数据量太小，优化器判断全表扫描比走索引更快。</li><li>使用了强制全表扫描的提示（Hint）。</li></ul></li></ul></li><li><p><strong>索引对 INSERT, UPDATE, DELETE 操作有什么影响？</strong></p><ul><li><strong>解答：</strong> 索引会降低 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 操作的性能。</li><li>每次进行这些写操作时，数据库不仅需要修改表中的实际数据行，还需要相应地更新、插入或删除相关索引中的条目，以保证索引与表数据的一致性。索引越多，写操作的开销越大。</li></ul></li><li><p><strong>什么是索引维护？索引碎片（Index Fragmentation）是什么？如何处理？</strong></p><ul><li><strong>解答：</strong><ul><li><strong>索引维护：</strong> 指的是通过重建或重组织等操作来优化索引的物理存储结构，以保持其查找效率。</li><li><strong>索引碎片：</strong> 当表中频繁发生插入、更新、删除操作时，数据行的物理存储顺序与索引的逻辑顺序可能变得不一致，或者索引页之间出现空隙、乱序。这种物理上的不连续性就是索引碎片。索引碎片会导致数据库在遍历索引时需要进行更多的随机磁盘 I&#x2F;O，降低性能。</li><li><strong>处理：</strong><ul><li><strong>重建索引 (Rebuild):</strong> 丢弃原有的索引结构，然后重新创建一个全新的索引。这是最彻底的碎片清理方式，通常能显著提高性能，但可能需要锁定表（取决于数据库和版本），是一个开销较大的操作。</li><li><strong>重组织索引 (Reorganize):</strong> 对索引的叶子节点进行整理和压缩，使其物理顺序更接近逻辑顺序。通常是在线操作，开销比重建小，适用于碎片程度较低的情况。</li></ul></li></ul></li></ul></li><li><p><strong>有一个慢查询，你首先会考虑哪些方面来优化，索引是其中的一步吗？</strong></p><ul><li><strong>解答：</strong> 优化慢查询是一个系统性的过程。首先会考虑以下方面：<ol><li><strong>理解查询：</strong> 明确查询的目的、涉及的表以及数据量。</li><li><strong>分析执行计划：</strong> 使用 <code>EXPLAIN</code> 或其他工具查看查询的执行计划，了解数据库是如何执行查询的（例如，是否使用了索引，使用了哪个索引，扫描了多少行，是否有文件排序等）。这是找到问题根源的关键一步。</li><li><strong>考虑索引：</strong> <strong>是的，索引是优化慢查询非常重要的一步。</strong> 根据执行计划分析，判断是否缺少合适的索引，或者现有索引是否被有效利用。考虑在 <code>WHERE</code>, <code>JOIN</code>, <code>ORDER BY</code>, <code>GROUP BY</code> 涉及的列上创建单列或联合索引。判断是否可以创建覆盖索引来避免回表。</li><li><strong>优化 SQL 语句本身：</strong> 检查 SQL 语句写法是否有问题，例如避免在索引列上使用函数，简化复杂的子查询或 JOIN，减少不必要的列查询（<code>SELECT *</code>），优化 <code>IN</code> 子句等。</li><li><strong>数据库统计信息：</strong> 确保数据库的统计信息是最新的，这有助于优化器做出正确的索引选择。</li><li><strong>数据库设计：</strong> 考虑表结构是否合理，是否存在范式问题，是否需要反范式优化（慎用）。</li><li><strong>硬件和配置：</strong> 如果是普遍性的性能问题，可能需要检查数据库服务器的硬件资源（CPU、内存、磁盘 I&#x2F;O）和数据库的配置参数。</li></ol></li><li>因此，分析执行计划后，考虑和优化索引是优化慢查询中必不可少且通常是首要的步骤之一。</li></ul></li><li><p><strong>你在实际项目中遇到过哪些索引相关的性能问题？是如何解决的？</strong></p><ul><li><strong>解答：</strong> （这需要根据个人实际经验来回答。以下是一个示例性的回答结构，您可以填充自己的具体案例。）<ul><li><strong>示例问题类型：</strong><ul><li><strong>缺少索引：</strong> 某个关键查询（例如，用于某个报表或列表页）非常慢，分析执行计划发现是全表扫描。</li><li><strong>索引选择不当：</strong> 存在索引，但优化器没有选择最高效的那个，或者选择了错误的索引。</li><li><strong>联合索引列顺序问题：</strong> 创建了联合索引，但查询没有遵循最左前缀原则，导致索引无法充分利用。</li><li><strong>过多索引：</strong> 对表创建了大量的索引，导致写操作（插入、更新）变得非常慢。</li><li><strong>索引失效：</strong> 在查询条件中对索引列使用了函数，导致索引失效。</li></ul></li><li><strong>解决思路（结合上述问题19的步骤）：</strong><ul><li>首先，<strong>复现问题</strong>并<strong>获取慢查询日志</strong>或直接执行查询获取<strong>执行计划</strong>。</li><li><strong>分析执行计划</strong>，定位问题是由于全表扫描、索引扫描效率低下、回表过多还是其他原因。</li><li><strong>根据分析结果制定索引优化方案：</strong><ul><li>如果缺少索引，根据查询的 <code>WHERE</code>, <code>JOIN</code>, <code>ORDER BY</code>, <code>GROUP BY</code> 条件创建合适的单列或联合索引。</li><li>如果索引选择不当，可能需要调整索引结构，或者考虑使用查询提示（Hint，慎用）来强制使用某个索引。</li><li>如果是联合索引问题，检查查询条件是否符合最左前缀，或者考虑调整联合索引的列顺序。</li><li>如果写操作慢，评估索引的必要性，删除不常用的或低效的索引。</li><li>如果索引失效，尝试重写 SQL 语句，避免在索引列上使用函数。</li></ul></li><li><strong>在测试环境验证</strong>优化效果，对比修改前后的执行计划和查询响应时间。</li><li><strong>谨慎部署</strong>到生产环境，并持续<strong>监控</strong>数据库性能。</li></ul></li></ul></li></ul></li></ol><h2 id="面试官出题"><a href="#面试官出题" class="headerlink" title="面试官出题"></a>面试官出题</h2><h3 id="常考题目"><a href="#常考题目" class="headerlink" title="常考题目"></a>常考题目</h3><h4 id="索引是什么结构"><a href="#索引是什么结构" class="headerlink" title="索引是什么结构"></a>索引是什么结构</h4><ul><li>B树</li><li>B+树</li></ul><h4 id="什么时候索引会失效？"><a href="#什么时候索引会失效？" class="headerlink" title="什么时候索引会失效？"></a>什么时候索引会失效？</h4><p>在 MySQL 数据库中，即使为表创建了索引，查询优化器也可能在某些情况下选择不使用这些索引，从而导致索引“失效”（即没有被用于加速查询）。以下是一些常见的导致 MySQL 索引失效的情况：<br><strong>核心要点（可以按类别总结）：</strong></p><ol><li><p><strong>对索引列进行操作或计算：</strong></p><ul><li>“首先，最常见的是<strong>在索引列上使用了函数或者进行了表达式计算</strong>。比如 <code>WHERE YEAR(date_col) = 2023</code> 或者 <code>WHERE indexed_col + 1 = 10</code>。这样做会导致 MySQL 无法直接利用索引的有序性。”</li></ul></li><li><p><strong>不恰当的 <code>LIKE</code> 查询：</strong></p><ul><li>“其次，使用 <code>LIKE</code> 查询时，如果<strong>通配符 <code>%</code> 用在了模式的开头</strong>，例如 <code>WHERE name LIKE &#39;%keyword&#39;</code>，索引也会失效，因为它无法确定搜索的起始点。”</li></ul></li><li><p><strong>违反最左前缀原则（针对复合索引）：</strong></p><ul><li>“对于复合索引（多列索引），查询条件<strong>没有遵循最左前缀原则</strong>。例如，如果索引是 <code>(col1, col2, col3)</code>，但查询条件是 <code>WHERE col2 = &#39;value&#39;</code> 或者 <code>WHERE col3 = &#39;value&#39;</code>，索引将不会被使用，或者部分使用。”</li></ul></li><li><p><strong>类型不匹配导致隐式转换：</strong></p><ul><li>“如果查询条件中的<strong>数据类型与索引列的数据类型不匹配</strong>，MySQL 可能会进行隐式类型转换，这通常会导致索引失效。比如，索引列是字符串，但查询时用了数字，反之亦然。”</li></ul></li><li><p><strong><code>OR</code> 条件的使用不当：</strong></p><ul><li>“当 <code>OR</code> 连接的条件中，<strong>有任何一方的列没有索引，或者优化器认为全表扫描的成本更低时</strong>，整个 <code>OR</code> 条件可能导致索引失效。即使两边都有索引，也可能出现这种情况。”</li></ul></li><li><p><strong>优化器的选择与数据特性：</strong></p><ul><li>“还有一些情况是 MySQL <strong>优化器基于成本的判断</strong>。例如：<ul><li><strong>表数据量过小</strong>，全表扫描可能比走索引更快。</li><li><strong>索引列的选择性过低</strong>（比如性别列），通过索引筛选不出多少数据，优化器可能放弃索引。</li><li><strong>统计信息不准确或过时</strong>，导致优化器做出错误的判断。”</li></ul></li></ul></li><li><p><strong>其他可能影响的情况（可选，如果时间允许或被追问）：</strong></p><ul><li>“某些情况下 <code>NOT IN</code>、<code>!=</code> (不等于) 操作符也可能导致索引失效。”</li><li>“如果 <code>ORDER BY</code> 的列和索引顺序不完全一致或混合升降序（特定版本和情况下）。”</li></ul></li></ol><p><strong>结尾与诊断方法：</strong></p><p>“总的来说，索引是否生效最终是由 MySQL 的查询优化器决定的。在实际工作中，我会<strong>使用 <code>EXPLAIN</code> 命令来分析查询执行计划</strong>，查看 <code>key</code> 列是否使用了预期的索引，以及 <code>Extra</code> 列是否有 <code>Using filesort</code> 或 <code>Using temporary</code> 等提示，来诊断索引是否失效以及具体原因。”</p><p><strong>回答技巧：</strong></p><ul><li><strong>结构清晰：</strong> 使用“首先”、“其次”、“再次”、“另外”、“最后”等词语引导。</li><li><strong>突出重点：</strong> 将最常见和最重要的情况放在前面。</li><li><strong>举例说明：</strong> 简短的例子能让你的解释更易懂。</li><li><strong>专业术语准确：</strong> 如“最左前缀原则”、“隐式类型转换”、“选择性”、“查询优化器”、“执行计划”。</li><li><strong>展现解决问题的能力：</strong> 提到 <code>EXPLAIN</code>表明你不仅知道问题，还知道如何诊断和解决。</li><li><strong>自信且流畅：</strong> 提前准备，多加练习。</li></ul><p><strong>面试官可能会追问的点：</strong></p><ul><li>“那针对XX情况，你会怎么优化？” (例如，对索引列使用函数怎么优化？)</li><li>“<code>EXPLAIN</code> 的输出中，哪些关键信息你会关注？”</li><li>“复合索引的设计有什么讲究？”</li></ul>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-分库分表</title>
      <link href="/2025/05/08/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2025/05/08/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h4 id="💡-一、为什么需要分库分表（动因）"><a href="#💡-一、为什么需要分库分表（动因）" class="headerlink" title="💡 一、为什么需要分库分表（动因）"></a>💡 一、为什么需要分库分表（动因）</h4><p><strong>核心目标：解决单库单表性能瓶颈。</strong></p><ul><li><p>数据量大 → 单表数据超千万行，查询慢、索引失效</p></li><li><p>并发高 → 单库连接数&#x2F;事务冲突瓶颈</p></li><li><p>运维难 → 备份、迁移、恢复时间长</p></li><li><p>可用性差 → 单点故障风险高，难以扩展</p></li></ul><p>✅ 示例句式：</p><blockquote><p>随着业务发展，单表数据量过大或请求并发过高，数据库响应延迟明显，单库承压，因此需要通过分库分表来提升系统的吞吐能力与可用性。</p></blockquote><h4 id="🧩-二、分库分表的方式与策略"><a href="#🧩-二、分库分表的方式与策略" class="headerlink" title="🧩 二、分库分表的方式与策略"></a>🧩 二、分库分表的方式与策略</h4><h5 id="1-拆分方式"><a href="#1-拆分方式" class="headerlink" title="1. 拆分方式"></a>1. 拆分方式</h5><ul><li><p><strong>垂直拆分</strong>（按业务模块拆库）：如用户、订单、商品拆成不同库</p></li><li><p><strong>水平拆分</strong>（按数据范围拆表）：如 <code>user_id</code> % N 拆成 user_0, user_1…</p></li></ul><h5 id="2-分片策略（Sharding-Key）"><a href="#2-分片策略（Sharding-Key）" class="headerlink" title="2. 分片策略（Sharding Key）"></a>2. 分片策略（Sharding Key）</h5><ul><li><p><strong>范围分片</strong>（如：按时间、ID区间）</p></li><li><p><strong>哈希分片</strong>（如：user_id % N）</p></li><li><p><strong>标签分片</strong>（如：地区、商户ID）</p></li></ul><p>✅ 示例句式：</p><blockquote><p>水平拆分时我们通常选取业务查询最频繁的字段作为分片键，比如 user_id，使用 hash 或 range 分片以保证数据均衡与高可用。</p></blockquote><hr><h4 id="⚙️-三、常见技术实现方式"><a href="#⚙️-三、常见技术实现方式" class="headerlink" title="⚙️ 三、常见技术实现方式"></a>⚙️ 三、常见技术实现方式</h4><h5 id="1-自研方案"><a href="#1-自研方案" class="headerlink" title="1. 自研方案"></a>1. 自研方案</h5><ul><li>在 DAO 层封装路由逻辑，结合 ThreadLocal 或 AOP 实现数据源动态切换</li><li>灵活但维护成本高，适合中小型项目</li></ul><h5 id="2-中间件方案（主流）"><a href="#2-中间件方案（主流）" class="headerlink" title="2. 中间件方案（主流）"></a>2. 中间件方案（主流）</h5><ul><li><p><strong>ShardingSphere-JDBC</strong>：支持分库分表、读写分离、柔性事务</p></li><li><p><strong>MyCat</strong>：基于代理的分布式数据库中间件</p></li><li><p><strong>TDDL</strong>：阿里内部方案</p></li><li><p><strong>Vitess、PolarDB-X、OceanBase</strong>：云原生一体化解决方案</p></li></ul><p>✅ 示例句式：</p><blockquote><p>我们团队使用 ShardingSphere-JDBC 实现分库分表，通过配置 sharding rule 动态路由数据源，配合读写分离有效降低主库压力。</p></blockquote><hr><h4 id="🔄-四、分布式事务与一致性问题"><a href="#🔄-四、分布式事务与一致性问题" class="headerlink" title="🔄 四、分布式事务与一致性问题"></a>🔄 四、分布式事务与一致性问题</h4><ul><li><p>分片后事务可能涉及多个库，难以使用本地事务</p></li><li><p>解决方案：</p><ul><li><p><strong>强一致性</strong>：使用 XA 两阶段提交（开销大）</p></li><li><p><strong>最终一致性</strong>：TCC、SAGA、消息补偿机制</p></li><li><p><strong>避开事务</strong>：通过业务逻辑控制，将操作限制在单分片内</p></li></ul></li></ul><p>✅ 示例句式：</p><blockquote><p>我们尽量通过业务分片控制事务边界落在同一个库上，如果无法避免跨库，则使用 TCC 模式实现柔性事务控制。</p></blockquote><hr><h4 id="📈-五、扩容与维护"><a href="#📈-五、扩容与维护" class="headerlink" title="📈 五、扩容与维护"></a>📈 五、扩容与维护</h4><ul><li><p><strong>扩容</strong>：如原先 4 分片扩到 8 分片 → 面临数据迁移、路由规则变更</p></li><li><p><strong>迁移策略</strong>：双写 + 验证 + 切换（或使用工具如 DataX、Canal）</p></li><li><p><strong>监控点</strong>：热点分布、分片倾斜、主从同步延迟、慢 SQL</p></li></ul><p>✅ 示例句式：</p><blockquote><p>在分片扩容时，我们采用“新旧双写+数据比对+流量切换”策略，确保数据一致性和用户无感知迁移。</p></blockquote><hr><h4 id="🧠-六、项目实战加分项（如有）"><a href="#🧠-六、项目实战加分项（如有）" class="headerlink" title="🧠 六、项目实战加分项（如有）"></a>🧠 六、项目实战加分项（如有）</h4><p>如果你曾实际在项目中用过分库分表，建议：</p><ul><li><p>简要描述场景、数据量、采用的中间件和策略</p></li><li><p>强调你解决的关键问题，如：分片键选择、事务方案、查询优化</p></li></ul><p>✅ 示例句式：</p><blockquote><p>在智慧教育平台项目中，因题库表数据超千万，查询频繁，我们使用 ShardingSphere 做水平分表，按 <code>question_id</code> 取模分为 8 表，并使用缓存+预查询优化了分页性能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-面经</title>
      <link href="/2025/05/08/%E9%9D%A2%E7%BB%8F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2025/05/08/%E9%9D%A2%E7%BB%8F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="MVCC存储在哪里，作用是什么"><a href="#MVCC存储在哪里，作用是什么" class="headerlink" title="MVCC存储在哪里，作用是什么"></a>MVCC存储在哪里，作用是什么</h3><h4 id="MVCC是什么"><a href="#MVCC是什么" class="headerlink" title="MVCC是什么"></a>MVCC是什么</h4><ul><li>传统的数据库并发控制通常使用锁机制，在并发量高的情况下容易导致阻塞和性能下降。</li><li>读不阻塞写，写不阻塞读；为每个事务维护一个数据快照；创建新版本而不是覆盖。</li><li></li></ul><h4 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h4><p>好的，我们来详细解释一下 MVCC（多版本并发控制）的实现机制。</p><p>MVCC 的核心思想是<strong>维护数据的多个版本</strong>，使得读操作可以不阻塞写操作，写操作也不会阻塞读操作。它主要依赖于以下几个关键组成部分和机制：</p><ol><li><p><strong>事务 ID (Transaction ID)</strong></p><p>每个事务在开始时都会被分配一个唯一的、递增的事务 ID。这个 ID 在 MVCC 中用于标记数据是由哪个事务创建或修改的。</p></li><li><p><strong>数据行的版本链 (Version Chain)</strong></p><p>MVCC 数据库中的每一行数据通常都会有几个隐藏的列，用于记录该行的版本信息。这些隐藏列通常包括：</p><ul><li><strong>创建事务 ID (TrxId 或 <code>DB_TRX_ID</code>)：</strong> 记录创建该行数据的事务 ID。</li><li><strong>删除事务 ID (DelTrxId) 或 指向 Undo Log 的指针 (<code>DB_ROLL_PTR</code>)：</strong><ul><li>有些实现会记录删除该行数据的事务 ID。</li><li>更常见的实现（如 InnoDB）是使用一个回滚指针 (<code>DB_ROLL_PTR</code>) 指向 Undo Log 中记录了该行修改前数据的一条记录。通过这个指针，可以将同一逻辑行（同一条记录）的不同版本通过 Undo Log 连接起来，形成一个版本链。最新的版本位于链的头部，旧版本通过指针连接到 Undo Log 中。</li></ul></li></ul></li><li><p><strong>Undo Log (回滚日志)</strong></p><p>Undo Log 在 MVCC 中扮演着至关重要的角色：</p><ul><li><strong>存储旧版本数据：</strong> 当一个事务修改（UPDATE 或 DELETE）一行数据时，修改前的旧版本数据会被写入 Undo Log。</li><li><strong>构建版本链：</strong> 数据行中的回滚指针 (<code>DB_ROLL_PTR</code>) 正是指向 Undo Log 中的对应记录，从而构建起数据行的版本链。这个链条记录了该行数据从最初创建到当前版本的所有修改历史。</li><li><strong>支持回滚：</strong> 当事务需要回滚时，可以通过 Undo Log 中的记录将数据恢复到修改前的状态。</li><li><strong>支持快照读：</strong> 这是 MVCC 实现非阻塞读的关键。当一个事务需要读取数据时，它会根据自身的事务 ID 和可见性规则，沿着版本链在 Undo Log 中找到符合条件的、对当前事务可见的数据版本进行读取。</li></ul></li><li><p><strong>Read View (读视图)</strong></p><p>每个事务在启动时（或者根据隔离级别的不同，在执行特定语句时）会创建一个 Read View（或类似的机制，如快照时间戳）。Read View 记录了当前活跃（尚未提交）的事务 ID 列表。这个 Read View 是判断数据版本对当前事务是否可见的关键。</p><p>Read View 通常包含以下信息：</p><ul><li><code>m_ids</code>: 当前活跃的事务 ID 列表。</li><li><code>min_trx_id</code>: <code>m_ids</code> 列表中最小的事务 ID。</li><li><code>max_trx_id</code>: 在创建 Read View 时，系统中应该分配给下一个事务的 ID，即当前最大的事务 ID + 1。</li><li><code>creator_trx_id</code>: 创建这个 Read View 的事务的 ID。</li></ul></li><li><p><strong>可见性判断规则</strong></p><p>当一个事务尝试读取一行数据时，数据库会根据该事务的 Read View 和数据行版本（由创建事务 ID <code>DB_TRX_ID</code> 标记）来判断这个版本是否对当前事务可见。具体的判断规则会根据事务隔离级别（如 Read Committed 或 Repeatable Read）有所不同，但基本原则如下：</p><ul><li>如果数据行版本的创建事务 ID (<code>DB_TRX_ID</code>) <strong>小于</strong> Read View 中的 <code>min_trx_id</code>，表示这个版本是由一个在当前事务启动之前就已经提交的事务所创建，因此该版本对当前事务<strong>可见</strong>。</li><li>如果数据行版本的创建事务 ID (<code>DB_TRX_ID</code>) <strong>大于等于</strong> Read View 中的 <code>max_trx_id</code>，表示这个版本是由一个在当前事务启动之后才开始的事务所创建，因此该版本对当前事务<strong>不可见</strong>。</li><li>如果数据行版本的创建事务 ID (<code>DB_TRX_ID</code>) <strong>在</strong> Read View 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> <strong>之间</strong>：<ul><li>如果 <code>DB_TRX_ID</code> <strong>等于</strong> Read View 中的 <code>creator_trx_id</code>，表示这个版本是当前事务自己修改的，因此对当前事务<strong>可见</strong>。</li><li>如果 <code>DB_TRX_ID</code> <strong>在</strong> Read View 的 <code>m_ids</code> 列表 <strong>中</strong>，表示这个版本是由一个在当前事务启动时仍然活跃（但尚未提交）的事务所创建，因此对当前事务<strong>不可见</strong>。</li><li>如果 <code>DB_TRX_ID</code> <strong>不在</strong> Read View 的 <code>m_ids</code> 列表 <strong>中</strong>，表示这个版本是由一个在当前事务启动时已经提交的事务所创建（但其 ID 在 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间），因此对当前事务<strong>可见</strong>。</li></ul></li></ul><p>如果当前数据行版本对当前事务不可见，数据库会沿着 Undo Log 中的版本链向前查找更旧的版本，并对找到的每个版本重复上述可见性判断，直到找到一个可见的版本或者版本链的末端。</p></li></ol><p><strong>读写操作在 MVCC 中的处理：</strong></p><ul><li><strong>读操作：</strong> 当一个事务执行读操作（例如 <code>SELECT</code>）时，它会使用自己的 Read View，根据上述可见性判断规则，从数据行的版本链中找到对自身可见的最新版本进行读取。这个过程不涉及对数据的加锁，因此读操作不会阻塞写操作。</li><li><strong>写操作 (UPDATE&#x2F;DELETE)：</strong> 当一个事务执行写操作时，它首先会像读操作一样找到对自身可见的最新版本数据。然后，它会将该版本的旧数据写入 Undo Log，并在数据行中创建或修改隐藏列，记录自己的事务 ID 和指向 Undo Log 的指针。新的数据版本只对创建它的事务或者后续启动并满足可见性规则的事务可见。写操作通常仍然需要对要修改的数据行加锁（写锁），以防止其他事务同时修改同一行，但这个锁通常只持续到事务提交或回滚，且不会阻塞读操作。</li><li><strong>写操作 (INSERT)：</strong> 当一个事务插入一行新数据时，它会在数据行中记录自己的事务 ID 作为创建事务 ID。新插入的数据行对创建它的事务可见，对于其他事务，其可见性也遵循上述可见性判断规则。</li></ul><p><strong>过期版本的清理 (Purge)</strong></p><p>随着事务不断进行修改，数据行会产生越来越多的旧版本存储在 Undo Log 中。这些旧版本如果不再被任何活跃事务所需要，就需要被清理掉，以释放存储空间。这个清理过程通常由一个后台线程（Purge 线程）负责。Purge 线程会根据当前系统中所有活跃事务的 Read View，确定哪些 Undo Log 中的旧版本数据已经不再可能被任何事务读取，然后进行物理删除。长事务会持有旧版本的 Read View，从而阻止对旧版本数据的清理，可能导致 Undo Log 不断增长。</p><p><strong>总结：</strong></p><p>MVCC 通过为每个事务提供一个数据快照，并利用事务 ID、数据行版本链和 Undo Log 来存储和管理数据的多个版本。通过 Read View 和可见性判断规则，MVCC 使得读操作可以并发进行而不会被写操作阻塞，显著提高了数据库的并发性能和吞吐量，同时提供了良好的事务隔离性（通常是 Snapshot Isolation 或 Read Committed）。</p><h4 id="MVCC存储在哪里"><a href="#MVCC存储在哪里" class="headerlink" title="MVCC存储在哪里"></a>MVCC存储在哪里</h4><ul><li><p><strong>数据行中的隐藏列：</strong> InnoDB 为每行数据添加了几个隐藏的系统列，其中与 MVCC 密切相关的主要有两个：</p><ul><li><code>DB_TRX_ID</code>：记录了最近一次修改（插入或更新）该行的事务 ID。删除在内部也被视为一种更新，会设置一个特殊的位标记。</li><li><code>DB_ROLL_PTR</code>：这是一个回滚指针，指向 Undo Log 中的一条记录。如果该行是被更新的，Undo Log 记录包含了重建更新前行内容所需的信息。通过这个指针和 Undo Log，可以找到该行的上一个版本。</li></ul></li><li><p><strong>Undo Log（回滚日志）：</strong></p><ul><li><strong>作用：</strong> Undo Log 是存储旧版本数据的地方。每当事务修改数据时，旧版本的数据会被写入 Undo Log。</li><li><strong>存储位置：</strong> Undo Log 存储在称为回滚段（rollback segment）的数据结构中，这些回滚段位于 Undo 表空间。Undo 表空间可以是共享的（在 <code>ibdataX</code> 文件中）或者独立的文件。</li><li><strong>MVCC 的依赖：</strong> 当一个事务需要读取某个数据行的旧版本时（根据事务自身的快照时间戳和数据行中的 <code>DB_TRX_ID</code> 判断），它会利用 <code>DB_ROLL_PTR</code> 沿着 Undo Log 的链条找到并重构出符合其可见性条件的旧版本数据。</li></ul></li></ul><h3 id="MysQl的几种log"><a href="#MysQl的几种log" class="headerlink" title="MysQl的几种log"></a>MysQl的几种log</h3><p>MySQL 中存在多种类型的日志文件，每种日志都有其特定的用途，对于数据库的监控、故障排查、数据恢复和复制至关重要。以下是 MySQL 中主要的几种日志：</p><ol><li><p><strong>错误日志 (Error Log)</strong></p><ul><li><strong>用途：</strong> 记录 MySQL 服务器运行过程中的各种错误信息、警告信息以及一些重要的事件，比如服务器的启动、关闭、崩溃等。</li><li><strong>作用：</strong> 这是排查 MySQL 服务器问题时首先应该查看的日志。它可以帮助你了解服务器为什么无法启动、为什么会意外关闭，或者在运行过程中出现了哪些异常情况。</li><li><strong>内容：</strong> 包含时间戳、事件类型（错误、警告、注意）、错误代码和描述等信息。</li></ul></li><li><p><strong>通用查询日志 (General Query Log)</strong></p><ul><li><strong>用途：</strong> 记录 MySQL 服务器接收到的每一个客户端连接以及客户端发送的所有 SQL 语句。</li><li><strong>作用：</strong> 这个日志可以非常详细地记录数据库的所有活动。它对于审计、追踪特定客户端的行为或者调试应用程序非常有用，可以准确地看到客户端向服务器发送了什么命令。</li><li><strong>注意：</strong> 由于会记录所有的操作，通用查询日志会非常庞大，并且对性能有一定影响，因此在生产环境中通常不建议长时间开启，除非是出于调试目的。</li></ul></li><li><p><strong>慢查询日志 (Slow Query Log)</strong></p><ul><li><strong>用途：</strong> 记录执行时间超过预设阈值的 SQL 语句。</li><li><strong>作用：</strong> 这是数据库性能优化的重要工具。通过分析慢查询日志，可以找出那些执行效率低下的查询语句，从而有针对性地进行优化，比如添加索引、重写查询语句等。</li><li><strong>内容：</strong> 包含查询语句本身、执行时间、锁定时间、发送给客户端的行数、扫描的行数等信息。可以通过配置 <code>long_query_time</code> 参数来设定慢查询的时间阈值。</li></ul></li><li><p><strong>二进制日志 (Binary Log 或 Binlog)</strong></p><ul><li><strong>用途：</strong> 记录所有更改了数据库数据或结构的语句（数据修改事件）。它以二进制格式存储，不记录 SELECT 等只读操作。</li><li><strong>作用：</strong> Binary Log 是 MySQL 复制（Replication）和数据恢复（Point-in-Time Recovery）的基础。<ul><li><strong>复制：</strong> 在主从复制架构中，主服务器将 Binlog 发送给从服务器，从服务器通过回放 Binlog 中的事件来保持与主服务器的数据同步。</li><li><strong>数据恢复：</strong> 在进行基于时间点的数据恢复时，可以使用全量备份加上 Binlog 来将数据库恢复到备份之后的任意时间点。</li></ul></li><li><strong>内容：</strong> 记录了导致数据改变的事件，可以是语句格式（Statement-Based Logging）、行格式（Row-Based Logging）或混合格式（Mixed-Based Logging）。</li></ul></li><li><p><strong>重做日志 (Redo Log)</strong></p><ul><li><strong>用途：</strong> 这是 InnoDB 存储引擎特有的日志，用于保证事务的持久性（Durability）。它记录了数据页的物理修改。</li><li><strong>作用：</strong> 当事务提交时，即使数据还没有来得及写入磁盘的数据文件中，事务的修改也已经被记录在 Redo Log 中了。如果数据库发生崩溃，在重启时 InnoDB 会检查 Redo Log，将已提交事务的修改从 Redo Log 中重放到数据文件中，确保数据不会丢失（Crash Recovery）。</li><li><strong>内容：</strong> 记录的是对数据页的物理修改操作，例如“在某某数据页的某某偏移量处写入某某值”。它是循环写入的，有一组固定大小的文件。</li></ul></li><li><p><strong>撤销日志 (Undo Log)</strong></p><ul><li><strong>用途：</strong> 这也是 InnoDB 存储引擎特有的日志，用于保证事务的原子性（Atomicity）和实现 MVCC（多版本并发控制）。它记录了数据修改前的旧版本数据。</li><li><strong>作用：</strong><ul><li><strong>事务回滚：</strong> 当事务需要回滚时，InnoDB 利用 Undo Log 中的信息将数据恢复到修改之前的状态，撤销事务所做的所有修改。</li><li><strong>MVCC：</strong> 在 MVCC 中，Undo Log 存储了数据行的多个历史版本。当一个事务读取数据时，如果当前的数据版本不可见，就会沿着 Undo Log 的版本链找到符合其可见性条件的旧版本数据进行读取。</li></ul></li><li><strong>内容：</strong> 记录的是逻辑操作，例如插入操作对应的 Undo Log 是删除操作，更新操作对应的 Undo Log 是将数据恢复到更新前的状态</li></ul></li></ol><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h4 id="💡-一、为什么需要分库分表（动因）"><a href="#💡-一、为什么需要分库分表（动因）" class="headerlink" title="💡 一、为什么需要分库分表（动因）"></a>💡 一、为什么需要分库分表（动因）</h4><p><strong>核心目标：解决单库单表性能瓶颈。</strong></p><ul><li><p>数据量大 → 单表数据超千万行，查询慢、索引失效</p></li><li><p>并发高 → 单库连接数&#x2F;事务冲突瓶颈</p></li><li><p>运维难 → 备份、迁移、恢复时间长</p></li><li><p>可用性差 → 单点故障风险高，难以扩展</p></li></ul><p>✅ 示例句式：</p><blockquote><p>随着业务发展，单表数据量过大或请求并发过高，数据库响应延迟明显，单库承压，因此需要通过分库分表来提升系统的吞吐能力与可用性。</p></blockquote><hr><h4 id="🧩-二、分库分表的方式与策略"><a href="#🧩-二、分库分表的方式与策略" class="headerlink" title="🧩 二、分库分表的方式与策略"></a>🧩 二、分库分表的方式与策略</h4><h5 id="1-拆分方式"><a href="#1-拆分方式" class="headerlink" title="1. 拆分方式"></a>1. 拆分方式</h5><ul><li><p><strong>垂直拆分</strong>（按业务模块拆库）：如用户、订单、商品拆成不同库</p></li><li><p><strong>水平拆分</strong>（按数据范围拆表）：如 <code>user_id</code> % N 拆成 user_0, user_1…</p></li></ul><h5 id="2-分片策略（Sharding-Key）"><a href="#2-分片策略（Sharding-Key）" class="headerlink" title="2. 分片策略（Sharding Key）"></a>2. 分片策略（Sharding Key）</h5><ul><li><p><strong>范围分片</strong>（如：按时间、ID区间）</p></li><li><p><strong>哈希分片</strong>（如：user_id % N）</p></li><li><p><strong>标签分片</strong>（如：地区、商户ID）</p></li></ul><p>✅ 示例句式：</p><blockquote><p>水平拆分时我们通常选取业务查询最频繁的字段作为分片键，比如 user_id，使用 hash 或 range 分片以保证数据均衡与高可用。</p></blockquote><hr><h4 id="⚙️-三、常见技术实现方式"><a href="#⚙️-三、常见技术实现方式" class="headerlink" title="⚙️ 三、常见技术实现方式"></a>⚙️ 三、常见技术实现方式</h4><h5 id="1-自研方案"><a href="#1-自研方案" class="headerlink" title="1. 自研方案"></a>1. 自研方案</h5><ul><li>在 DAO 层封装路由逻辑，结合 ThreadLocal 或 AOP 实现数据源动态切换</li><li>灵活但维护成本高，适合中小型项目</li></ul><h5 id="2-中间件方案（主流）"><a href="#2-中间件方案（主流）" class="headerlink" title="2. 中间件方案（主流）"></a>2. 中间件方案（主流）</h5><ul><li><p><strong>ShardingSphere-JDBC</strong>：支持分库分表、读写分离、柔性事务</p></li><li><p><strong>MyCat</strong>：基于代理的分布式数据库中间件</p></li><li><p><strong>TDDL</strong>：阿里内部方案</p></li><li><p><strong>Vitess、PolarDB-X、OceanBase</strong>：云原生一体化解决方案</p></li></ul><p>✅ 示例句式：</p><blockquote><p>我们团队使用 ShardingSphere-JDBC 实现分库分表，通过配置 sharding rule 动态路由数据源，配合读写分离有效降低主库压力。</p></blockquote><hr><h4 id="🔄-四、分布式事务与一致性问题"><a href="#🔄-四、分布式事务与一致性问题" class="headerlink" title="🔄 四、分布式事务与一致性问题"></a>🔄 四、分布式事务与一致性问题</h4><ul><li><p>分片后事务可能涉及多个库，难以使用本地事务</p></li><li><p>解决方案：</p><ul><li><p><strong>强一致性</strong>：使用 XA 两阶段提交（开销大）</p></li><li><p><strong>最终一致性</strong>：TCC、SAGA、消息补偿机制</p></li><li><p><strong>避开事务</strong>：通过业务逻辑控制，将操作限制在单分片内</p></li></ul></li></ul><p>✅ 示例句式：</p><blockquote><p>我们尽量通过业务分片控制事务边界落在同一个库上，如果无法避免跨库，则使用 TCC 模式实现柔性事务控制。</p></blockquote><hr><h4 id="📈-五、扩容与维护"><a href="#📈-五、扩容与维护" class="headerlink" title="📈 五、扩容与维护"></a>📈 五、扩容与维护</h4><ul><li><p><strong>扩容</strong>：如原先 4 分片扩到 8 分片 → 面临数据迁移、路由规则变更</p></li><li><p><strong>迁移策略</strong>：双写 + 验证 + 切换（或使用工具如 DataX、Canal）</p></li><li><p><strong>监控点</strong>：热点分布、分片倾斜、主从同步延迟、慢 SQL</p></li></ul><p>✅ 示例句式：</p><blockquote><p>在分片扩容时，我们采用“新旧双写+数据比对+流量切换”策略，确保数据一致性和用户无感知迁移。</p></blockquote><hr><h4 id="🧠-六、项目实战加分项（如有）"><a href="#🧠-六、项目实战加分项（如有）" class="headerlink" title="🧠 六、项目实战加分项（如有）"></a>🧠 六、项目实战加分项（如有）</h4><p>如果你曾实际在项目中用过分库分表，建议：</p><ul><li><p>简要描述场景、数据量、采用的中间件和策略</p></li><li><p>强调你解决的关键问题，如：分片键选择、事务方案、查询优化</p></li></ul><p>✅ 示例句式：</p><blockquote><p>在智慧教育平台项目中，因题库表数据超千万，查询频繁，我们使用 ShardingSphere 做水平分表，按 <code>question_id</code> 取模分为 8 表，并使用缓存+预查询优化了分页性能。</p></blockquote><h4 id="如何分库分表"><a href="#如何分库分表" class="headerlink" title="如何分库分表"></a>如何分库分表</h4><p>“MySQL 分库分表是为了应对<strong>数据量和并发量达到单机瓶颈</strong>时的扩展性问题。它将数据分散存储到多个数据库实例或表中。</p><p>主要方式有两种：</p><ol><li><strong>垂直拆分：</strong><ul><li><strong>分库：</strong> 按<strong>业务模块</strong>将不同表放到不同数据库（例如用户库、订单库）。</li><li><strong>分表：</strong> 按<strong>字段热度</strong>将一张表的大字段或不常用字段拆分到另一张表。</li><li><strong>目的：</strong> 缓解不同业务&#x2F;字段的IO压力。</li></ul></li><li><strong>水平拆分：</strong><ul><li><strong>分库分表：</strong> 按<strong>数据行</strong>将一张表的数据分散到多个库或多个表中。</li><li><strong>目的：</strong> 彻底解决单表数据量过大的问题，提升整体吞吐量。</li><li><strong>关键：</strong> 选择合适的分片键（如ID取模、哈希、范围等），并依赖<strong>中间件（如ShardingSphere、MyCAT）或应用层逻辑</strong>来实现路由。</li></ul></li></ol><h4 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h4><p>MySQL 索引失效，意味着查询无法使用索引而进行<strong>全表扫描</strong>，严重影响性能。主要原因在于<strong>查询条件破坏了索引的有序性或无法有效利用B+树结构</strong>。</p><p>常见的失效情况和避免方法有：</p><ol><li><strong>对索引列进行函数或表达式操作：</strong> <code>WHERE YEAR(time) = 2023</code>。<ul><li><strong>避免：</strong> 把函数&#x2F;表达式作用于查询值，如 <code>WHERE time &gt;= &#39;2023-01-01&#39; ...</code>。</li></ul></li><li><strong><code>LIKE</code> 以 <code>%</code> 开头进行模糊匹配：</strong> <code>WHERE name LIKE &#39;%张三%&#39;</code>。<ul><li><strong>避免：</strong> 尽量使用前缀匹配 <code>LIKE &#39;张三%&#39;</code> 或考虑全文索引。</li></ul></li><li><strong>隐式类型转换：</strong> <code>WHERE phone = 123</code> (phone是VARCHAR)。<ul><li><strong>避免：</strong> 确保查询条件类型与索引列类型一致。</li></ul></li><li><strong><code>OR</code> 连接非同一索引列：</strong> <code>WHERE col1 = &#39;A&#39; OR col2 = &#39;B&#39;</code>。<ul><li><strong>避免：</strong> 考虑 <code>UNION ALL</code> 或为相关列创建<strong>联合索引</strong>。</li></ul></li><li><strong>联合索引未遵循“最左前缀原则”：</strong> <code>(a,b,c)</code> 索引，但查询 <code>WHERE b = 1</code>。<ul><li><strong>避免：</strong> 查询条件从最左列开始且连续使用。</li></ul></li><li><strong><code>!=</code> 或 <code>NOT IN</code>：</strong> 这类非等值查询通常效率低，优化器可能选择全表扫描。</li></ol><p><strong>判断索引是否生效，主要使用 <code>EXPLAIN</code> 命令</strong>，查看 <code>type</code>、<code>key</code> 和 <code>Extra</code> 字段，特别是 <code>ALL</code>、<code>Using filesort</code>、<code>Using temporary</code> 等提示。”</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刘邦大传</title>
      <link href="/2024/11/07/%E5%88%98%E9%82%A6%E5%A4%A7%E4%BC%A0/"/>
      <url>/2024/11/07/%E5%88%98%E9%82%A6%E5%A4%A7%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="观刘邦大传有所感的句子"><a href="#观刘邦大传有所感的句子" class="headerlink" title="观刘邦大传有所感的句子"></a>观刘邦大传有所感的句子</h4><ul><li><p>柔弱生之徒，老式戒刚强</p></li><li><p>天地不仁，以万物为刍狗；圣人不仁，以百姓为刍狗</p></li><li><p>失败的痛苦对我们对我们虽然最有用处，但往往是最容易被忘掉的；成功的骄傲最容易误导我们日后的行为，却也是最不容易抛弃的一部分。</p></li><li><p>攻击自己的勇气，是赢家最好的防守策略</p></li><li><p>不刻意去追求成功，没有包袱，没有私欲，只有努力，不断努力去解决周边的困难，努力到不必可以用心去努力的程度，便也是最容易成功的时候。真正的成功者，大多是冒险家，或许他们审慎小心，但多半是没有任何包袱压力的。身段太多，顾前顾后，刻意去追求成功的人，反而很少真正的成功</p></li><li><p>要笨到不会在乎会得到什么结果，要狂到肯把自己的一切全投入到工作中，要天真到不想一个人独享成果，要懒散到有一大推人替你工作</p></li><li><p>最上等的领导者无为而治，人们只知道有国君，而不感觉到其势力，各顺其性，各安起身。一切都制度化，每个人遵循运作模式，各自负责其工作，达成其任务。</p></li><li><p>真正的政治领袖，会努力建立制度化的常模，不喊口号，也不可以呼吁民众效忠，时机不成熟，绝不发号施令。有耐心地维持住常态的努力工作，让一切顺理成章的达成其目标，人民感受不出领导者的手段，只认为一切本应该如此</p></li><li><p>守弱—知道自己的孱弱，而能够接纳这种弱势，坚强地忍耐弱者的地位，才能累积实力。是自己慢慢脱离弱者的不利地位</p></li><li><p>人的需要真实非常有限，知识欲望确实无穷的，过分追求欲望而不能节制，结果经常不能满足，反而更加痛苦，而无法掌控自我的意志</p></li><li><p>人类最大的敌人是自己，最不容战胜的对手是自己，但事实上，人类唯一能影响，去改变的也是自己</p></li><li><p>不要像美玉一样地摧残而为人尊崇，而要像坚石一样黯淡而为人贱视，一切都合乎道，不用特别造作，使天地万物趋向于自然</p></li><li><p>欲取天下者，应顺应自然之势，不应过分着重人为的努力。若有人想以一己之力来统治天下，这是绝对做不到的</p></li><li><p>一切顺其自然，堵塞意念，关闭情欲，收敛锋芒，消除丰饶于未然，不表示自己的特异，与光则和，遇尘则同</p></li><li><p>当我们用别人的眼光来评判自己，确定自己的价值，这便是输赢心态的开始，输赢让我们紧张，焦虑，让我们的思想被封闭了，为了他人的评价而活，拼命压抑自己的感觉。不能去除输赢的心态，便无法共赢，不能体认与接纳自己的感觉，我们便无法克服输赢的焦虑</p></li><li><p>靠赢家赢的那批人，往往更输不起，他们会迫使赢家继续去赢</p></li><li><p>狡兔死，走狗烹，飞鸟尽，良弓藏，敌国破，良臣灭</p></li><li><p>虏中吾指</p></li><li><p>吾以布衣提三尺剑取天下，此非天命乎？命乃在天，虽扁鹊何益！</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>foo1s的第一篇博客</title>
      <link href="/2024/11/06/foo1s%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/11/06/foo1s%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="foo1s的第一篇博客"><a href="#foo1s的第一篇博客" class="headerlink" title="foo1s的第一篇博客"></a>foo1s的第一篇博客</h1><h2 id="1-博客的创建"><a href="#1-博客的创建" class="headerlink" title="1.博客的创建"></a>1.博客的创建</h2><h3 id="1-1-博客的创建"><a href="#1-1-博客的创建" class="headerlink" title="1.1.博客的创建"></a>1.1.博客的创建</h3><h4 id="1-1-1-博客的创建"><a href="#1-1-1-博客的创建" class="headerlink" title="1.1.1.博客的创建"></a>1.1.1.博客的创建</h4><h5 id="1-1-1-1-博客的创建"><a href="#1-1-1-1-博客的创建" class="headerlink" title="1.1.1.1.博客的创建"></a>1.1.1.1.博客的创建</h5><h6 id="1-1-1-1-1-博客的创建"><a href="#1-1-1-1-1-博客的创建" class="headerlink" title="1.1.1.1.1.博客的创建"></a>1.1.1.1.1.博客的创建</h6><h3 id="1-2-博客的创建"><a href="#1-2-博客的创建" class="headerlink" title="1.2.博客的创建"></a>1.2.博客的创建</h3><h4 id="1-2-1-博客的创建"><a href="#1-2-1-博客的创建" class="headerlink" title="1.2.1.博客的创建"></a>1.2.1.博客的创建</h4><h5 id="1-2-1-1-博客的创建"><a href="#1-2-1-1-博客的创建" class="headerlink" title="1.2.1.1.博客的创建"></a>1.2.1.1.博客的创建</h5><h6 id="1-2-1-1-1-博客的创建"><a href="#1-2-1-1-1-博客的创建" class="headerlink" title="1.2.1.1.1.博客的创建"></a>1.2.1.1.1.博客的创建</h6>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/11/06/hello-world/"/>
      <url>/2024/11/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
